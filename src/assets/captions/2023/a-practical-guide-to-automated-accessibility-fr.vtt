WEBVTT

00:00:00.984 --> 00:00:05.690
Journée de l'accessibilité WordPress
2023, un guide pratique

00:00:05.690 --> 00:00:09.930
Sur l'accessibilité automatisée
avec Mark Steadman, directeur,

00:00:09.930 --> 00:00:13.220
Accessibilité mobile chez
Fidelity Investments.

00:00:13.220 --> 00:00:17.210
Cette présentation a été
enregistrée le 28 septembre 2023.

00:00:17.210 --> 00:00:22.500
<v Joost de Valk> C'est un plaisir pour moi
de présenter notre prochain conférencier,

00:00:22.500 --> 00:00:25.750 
Mark Steadman, qui nous
parlera d'un guide pratique

00:00:25.750 --> 00:00:27.500
sur l'accessibilité automatisée.

00:00:29.170 --> 00:00:32.130
Mark est le directeur de
l'ingénierie logicielle pour l'accessibilité mobile.

00:00:32.130 --> 00:00:33.870
chez Fidelity Investments.

00:00:33.870 --> 00:00:38.410
Et avec une ferveur pour
l'automatisation de l'accessibilité et un fort plaidoyer

00:00:38.410 --> 00:00:42.960
pour que les développeurs priorisent
l'accessibilité, Mark a pour mission

00:00:42.960 --> 00:00:47.170
de rendre le contenu web et mobile
accessible à tous.

00:00:47.170 --> 00:00:51.340
Juste une petite mission,
pas une grande entreprise.

00:00:51.340 --> 00:00:55.240
Son objectif principal est
de collaborer avec les équipes de développement

00:00:55.240 --> 00:00:57.470
afin d'intégrer l'accessibilité,
et c'est tellement sympa.

00:00:57.470 --> 00:01:00.100
C'est le troisième
intervenant que je présente.

00:01:00.100 --> 00:01:02.140
Ils collaborent tous les trois
avec les équipes de développement.

00:01:02.140 --> 00:01:05.580
J'aime vraiment voir ça.

00:01:05.580 --> 00:01:08.910
Il considérait cela comme un
élément crucial du développement continu

00:01:08.910 --> 00:01:11.430
et des processus d'intégration continue.

00:01:11.430 --> 00:01:13.840
Non seulement il a été le
pionnier dans la création de

00:01:13.840 --> 00:01:17.850
solutions d'automisation de l'accessibilité,
mais il a également joué un rôle déterminant

00:01:17.850 --> 00:01:20.600
dans l'intégration de ces
solutions au coeur

00:01:20.600 --> 00:01:23.960
des équipes de développement et
des organisations pour lesquelles il a travaillé.

00:01:23.960 --> 00:01:28.120
Veuillez vous joindre à moi pour souhaiter
chaleureusement la bienvenue à Mark Steadman.

00:01:28.120 --> 00:01:29.910
Mark, c'est à toi.

00:01:29.910 --> 00:01:30.960
<v Mark Steadman> Génial.

00:01:30.960 --> 00:01:31.280
Bien.

00:01:31.280 --> 00:01:33.600
Eh bien, pour moi,
c'est une bonne matinée pour tout le monde.

00:01:33.600 --> 00:01:37.650
Il est 6 heures du matin et j'ai bu du café, alors
tout le monde ferait mieux de faire attention maitenant

00:01:37.650 --> 00:01:42.220
parce que je suis prêt à foncer à
plein régime vu que je suis carburé

00:01:42.220 --> 00:01:42.670
au café.

00:01:42.670 --> 00:01:46.390
Alors bonjour, bon après-midi, bonsoir
, quelle que soit la période.

00:01:46.390 --> 00:01:47.600
C'est génial.

00:01:47.600 --> 00:01:50.414
Pour moi, aux États-Unis,
c'est ainsi que commence votre journée

00:01:50.415 --> 00:01:52.290
avec l'accessibilité automatisée.

00:01:52.290 --> 00:01:56.610
Je suis donc ravi de pouvoir
discuter avec vous tous aujourd'hui.

00:01:56.610 --> 00:01:59.710
Et nous ferions mieux de
débuter parce que nous avons beaucoup de sujets

00:01:59.710 --> 00:02:01.820
à couvrir en peu de
temps, ce qui est normalement la

00:02:01.820 --> 00:02:02.680
façon dont je fais toutes mes présentations.

00:02:02.680 --> 00:02:05.880
Donc encore une fois, très rapidement,
Mark Steadman, je veux juste

00:02:05.880 --> 00:02:07.350
ajouter ces choses
ici très rapidement.

00:02:07.350 --> 00:02:10.070
Si vous voulez me suivre sur
Twitter ou X ou quoi que ce soit

00:02:10.070 --> 00:02:15.120
d'autre à ce rythme, je suis
@steady, STEADY 5063.

00:02:15.120 --> 00:02:18.630
Et puis vous pouvez me retrouver sur
LinkedIn avec Mark Steadman

00:02:18.630 --> 00:02:20.470
ou juste mark_steady si
vous voulez me trouver.

00:02:21.490 --> 00:02:25.370
Donc, les objectifs d'apprentissage
pour cette conférence.

00:02:25.370 --> 00:02:28.350
Je suis très content de faire ceci parce que
cette conversation est l'une de celles

00:02:28.350 --> 00:02:30.540
qui me passionnent beaucoup.

00:02:30.540 --> 00:02:33.920
Pourquoi l'automatisation de l'accessibilité est
importante pour construire une fondation

00:02:33.920 --> 00:02:37.220
d'accessibilité dans le
cycle de vie du développement ?

00:02:37.220 --> 00:02:38.830
Pourquoi cela a gagné en popularité ?

00:02:38.830 --> 00:02:42.210
Et les problèmes qui ont été soulevés
avec cette même popularité.

00:02:42.210 --> 00:02:45.900
Comment utiliser efficacement le "linting"
comme première étape du processus.

00:02:45.900 --> 00:02:47.240
Et pourquoi est-ce un si
bon point de départ ?

00:02:47.240 --> 00:02:49.692
Et puis comment
utiliser efficacement les bibliothèques de tests

00:02:49.693 --> 00:02:50.820
et les tests de régression

00:02:50.820 --> 00:02:53.030
pour garantir
un contenu accessible.

00:02:53.030 --> 00:02:55.570
Maintenant, cela semble beaucoup,
mais au fur et à mesure que nous avancerons,

00:02:55.570 --> 00:02:57.020
Je vais détailler
au fur et à mesure

00:02:57.020 --> 00:03:00.460
pour rendre le tout un peu
plus simple et plus facile à digérer

00:03:00.460 --> 00:03:02.790
pour peut-être ceux qui ne sont pas
familiers avec les équipes de développement,

00:03:02.790 --> 00:03:04.290
les processus de développement.

00:03:04.290 --> 00:03:06.820
Et aussi pour ceux qui sont
développeurs et qui se disent :

00:03:06.820 --> 00:03:10.420
comment puis-je intégrer cela correctement
pour inclure l'accessibilité

00:03:10.420 --> 00:03:11.710
dans le cadre de mon
cycle de vie de développement ?

00:03:13.070 --> 00:03:16.130
Donc, l'accessibilité le "Shift Left" (décalage vers la gauche).

00:03:16.130 --> 00:03:20.820
Pour comprendre comment l'automatisation de
l'accessibilité est arrivée là,

00:03:20.820 --> 00:03:23.160
vous devez comprendre
par où est passée l'industrie.

00:03:23.160 --> 00:03:26.240
Et donc la plupart des gens sont probablement
familiers avec cela, mais c'est un peu

00:03:26.240 --> 00:03:27.470
une bonne mise en contexte
pour tout le monde ici.

00:03:27.470 --> 00:03:32.440
Le déplacement vers la gauche était donc l'idée
popularisée par l'industrie DevOps,

00:03:32.440 --> 00:03:37.550
où nous avons dit, Hey, ça coûte moins cher
de trouver et de corriger les bugs plus tôt

00:03:37.550 --> 00:03:40.370
dans le
cycle de vie du développement. C'est le bon sens, n'est-ce pas ?

00:03:40.370 --> 00:03:44.450
Cependant, pendant très longtemps,
cela n'a pas toujours été le cas.

00:03:44.450 --> 00:03:47.260
Ce qui était le cas était que nous
faisions une sorte de modèle cascade

00:03:47.260 --> 00:03:52.800
ou un modèle où nous
créerions, pousserions, passerions en production,

00:03:52.800 --> 00:03:54.200
puis corrigions le contenu par la suite.

00:03:54.200 --> 00:03:58.280
Eh bien, l'industrie DevOps a dit :
non, déplaçons ce contexte vers la gauche.

00:03:58.280 --> 00:04:00.600
afin que nous puissions corriger
les bugs plus tôt et à moindre coût.

00:04:00.600 --> 00:04:03.320
Donc ce que j'ai sur l'
écran est une image

00:04:03.320 --> 00:04:07.470
qui dit essentiellement que vous créez,
vous planifiez, vous surveillez, vous configurez,

00:04:07.470 --> 00:04:10.100
publiez, empaquetez, vérifiez,
et puis le cycle recommence et tourne

00:04:10.100 --> 00:04:10.860
dans une boucle infinie.

00:04:10.860 --> 00:04:12.650
Parce que c'est essentiellement
ce qu'est le décalage vers la gauche.

00:04:12.650 --> 00:04:16.180
Vous corrigez constamment des bugs,
créez constamment du contenu,

00:04:16.180 --> 00:04:18.840
et cela aide d'
un point de vue agile.

00:04:18.840 --> 00:04:22.900
Eh bien, quand cela a commencé à devenir
très populaire, l'idée est venue,

00:04:22.900 --> 00:04:25.980
comment l'accessibilité pourrait-elle
s'intégrer dans ce modèle ?

00:04:25.980 --> 00:04:29.520
Parce que l'accessibilité
a toujours été, depuis très longtemps,

00:04:29.520 --> 00:04:32.790
ou l'a été,
réparons-le après coup.

00:04:32.790 --> 00:04:35.850
Je suis sûr que tout le monde ici en
ce moment est en train de se dire

00:04:35.850 --> 00:04:37.180
J'ai entendu ça des milliers de fois.

00:04:37.180 --> 00:04:37.680
C'est vrai.

00:04:37.680 --> 00:04:39.990
Cela a toujours été le cas
, nous allons le corriger plus tard.

00:04:41.220 --> 00:04:46.460
Mais avec ce changement, nous nous sommes dit :
Hé, est-ce qu'on peut en faire partie ?

00:04:46.460 --> 00:04:49.830
C'est alors qu'est né l'essor de
l'accessibilité automatisée.

00:04:49.830 --> 00:04:51.650
Et je suis un grand fan de Star Wars.

00:04:51.650 --> 00:04:53.520
Je sais que j'ai le truc de WordPress
juste derrière, mais si vous pouviez voir.

00:04:53.520 --> 00:04:54.980
J'ai mille
sabres laser derrière moi,

00:04:54.980 --> 00:04:56.790
un tas de différents
objets Star Wars.

00:04:56.790 --> 00:05:00.450
J'ai donc créé ce logo disant :
"Ally Wars", la montée de l'automatisation

00:05:00.450 --> 00:05:03.770
dans la police Star Wars, parce que
c'est essentiellement ce que c'était.

00:05:03.770 --> 00:05:06.640
L'accessibilité automatisée
a explosé pour s'adapter à ce modèle.

00:05:06.640 --> 00:05:12.270
Tout,
des bibliothèques d'accessibilité, des extensions, des utilitaires d'aide,

00:05:14.790 --> 00:05:17.120
vous le nommez, il a sa propre chose.

00:05:17.120 --> 00:05:20.522
Et donc avec cette
chose, nous essayions

00:05:20.523 --> 00:05:23.400
de combler autant de lacunes que possible.

00:05:23.400 --> 00:05:26.230
Donc avec tous les différents
langages de développement, frameworks,

00:05:26.230 --> 00:05:29.500
tout cela, nous avons tenté d'intégrer
ce modèle afin de pouvoir obtenir

00:05:29.500 --> 00:05:32.850
autant d'accessibilité automatisée
que possible dans ces processus.

00:05:32.850 --> 00:05:36.390
Et sur papier, cela semble merveilleux.

00:05:36.390 --> 00:05:39.070
Cela présente donc d'énormes
avantages.

00:05:39.070 --> 00:05:41.520
C'est une intégration 
simple et rapide de l'accessibilité

00:05:41.520 --> 00:05:42.720
dans le cycle de vie du développement.

00:05:42.720 --> 00:05:43.940
C'est parfait ?

00:05:43.940 --> 00:05:44.930
Absolument pas.

00:05:44.930 --> 00:05:47.610
Non, c'est juste une
quantité minime ou une petite quantité,

00:05:47.610 --> 00:05:49.460
probablement le tiers inférieur
des problèmes d'accessibilité.

00:05:49.460 --> 00:05:53.460
Cependant, cela s'intègre parfaitement
dans n'importe quel processus agile

00:05:53.460 --> 00:05:55.080
que nous faisons pour l'accessibilité.

00:05:55.080 --> 00:05:58.360
Donc c'est vraiment une victoire facile
car il n'y a aucun contre-indicatif

00:05:58.360 --> 00:05:59.840
du côté du développeur.

00:05:59.840 --> 00:06:02.560
Je dis juste, Hé, nous devons
ajouter cela, et cela convient parfaitement

00:06:02.560 --> 00:06:04.310
dans le système que nous mettons en place.

00:06:04.310 --> 00:06:06.970
Cela aide à augmenter
les connaissances des développeurs sur l'accessibilité.

00:06:06.970 --> 00:06:09.440
La plupart des outils automatisés sont donc dotés
de leur propre documentation

00:06:09.440 --> 00:06:11.520
ou vous guide vers de la documentation
pour vous aider.

00:06:12.540 --> 00:06:15.310
Croyez-le ou non, cela impose
de bonnes pratiques de codage de l'interface utilisateur.

00:06:15.310 --> 00:06:19.970
Si je pouvais voir tout le monde ici et
vous voir tous sur l'écran en ce moment,

00:06:19.970 --> 00:06:22.690
tout le monde serait déprimé
quand je disais : [Inaudible 06:22]

00:06:22.690 --> 00:06:23.690
ce n'est pas bon.

00:06:24.650 --> 00:06:27.720
Cela aide donc à appliquer
de bonnes pratiques de codage de l'interface utilisateur.

00:06:29.100 --> 00:06:30.950
Cela permet une
application accessible afin que vous puissiez utiliser

00:06:30.950 --> 00:06:36.370
les pipelines d'actions de GitHub,
et cela contribue à bâtir une culture

00:06:36.370 --> 00:06:37.560
qui inclut l'accessibilité.

00:06:37.560 --> 00:06:40.480
Vous allez m'entendre dire cela
encore et encore pendant cette conférence.

00:06:40.480 --> 00:06:42.026
C'est le plus gros morceau

00:06:42.027 --> 00:06:44.810
avec une
bonne accessibilité automatisée.

00:06:44.810 --> 00:06:48.220
Si vous vous trompez, vous perdez
rapidement des gens, mais si vous faites les choses correctement,

00:06:48.220 --> 00:06:51.160
cela aide à établir les bases
pour bâtir une culture

00:06:51.160 --> 00:06:53.840
d'accessibilité au fil du temps.

00:06:53.840 --> 00:06:54.850
C'est le but ultime.

00:06:54.850 --> 00:06:58.380
Oui, l'automatisation est un
point de départ, mais vous pouvez contribuer à l'ancrer

00:06:58.380 --> 00:07:00.900
dans votre culture du côté
du développement facilement

00:07:00.900 --> 00:07:02.440
si vous le faites correctement.

00:07:02.440 --> 00:07:05.080
Si vous vous trompez, vous pouvez
perdre des gens relativement rapidement,

00:07:05.080 --> 00:07:07.690
mais ce sont là les grands avantages
de l'accessibilité automatisée.

00:07:07.690 --> 00:07:09.700
Alors vous vous
dites, Mark, c'est super.

00:07:09.700 --> 00:07:10.380
En quoi c'est une grande affaire ?

00:07:10.380 --> 00:07:13.410
Pourquoi suis-je ici en train de vous parler
en ce moment ? En quoi est-ce important ?

00:07:14.800 --> 00:07:15.650
Eh bien, c'est une grande affaire.

00:07:15.650 --> 00:07:17.980
C'est devenu une surcharge d'automatisation.

00:07:17.980 --> 00:07:20.320
Ce que j'ai sur l'écran, c'est
juste un tas de logos différents.

00:07:20.320 --> 00:07:22.820
pour un tas d'extensions différentes
qui font un tas de choses différentes,

00:07:22.820 --> 00:07:25.490
mais globalement,
ils font la même chose.

00:07:25.490 --> 00:07:28.740
Ils vérifient les
problèmes d'accessibilité de manière automatisée.

00:07:30.450 --> 00:07:31.610
Voilà ce qui s'est passé.

00:07:31.610 --> 00:07:36.960
Nous étions très excités à l'idée de réaliser
un tas d'automatisations,

00:07:36.960 --> 00:07:38.970
de s'adapter à ces cycles de vie,
de s'adapter à ces produits,

00:07:38.970 --> 00:07:43.170
et ce qui s'est passé,
c'est que nous nous sommes retrouvés avec une surcharge.

00:07:43.170 --> 00:07:46.010
Et tous les développeurs avec qui
je parlais, chaque équipe

00:07:46.010 --> 00:07:50.080
avec qui j'ai parlé disait,
par où diable dois-je commencer ?

00:07:50.080 --> 00:07:51.560
Parce que je ne sais pas.

00:07:51.560 --> 00:07:52.770
Il y a tellement de choses qui existent.

00:07:52.770 --> 00:07:53.760
Je ne sais pas quoi utiliser.

00:07:53.760 --> 00:07:54.530
Quel est le meilleur ?

00:07:54.530 --> 00:07:56.930
Comment cela s'intègre-t-il à mon équipe ?
Peu importe ce que c'est.

00:07:56.930 --> 00:07:59.580
Nous nous sommes donc retrouvés avec plusieurs
bibliothèques d'accessibilité open source,

00:07:59.580 --> 00:08:03.360
certaines des meilleures idées, XCOR,
Pali, extensions de navigateur, Wave,

00:08:03.360 --> 00:08:06.740
Lighthouse, Microsoft Insights,
Act Step Tools, n'est-ce pas ?

00:08:06.740 --> 00:08:10.710
Il existe une multitude de linters,
qui commencent à ajouter des règles d'accessibilité

00:08:10.710 --> 00:08:14.610
et tout le monde disait, il y a
ESLint, Acts Linter, il y a ASLint,

00:08:14.610 --> 00:08:16.190
il y en a plusieurs
différents.

00:08:16.190 --> 00:08:20.750
Et donc en tant que développeurs,
tout le monde regarde cela et se dit,

00:08:20.750 --> 00:08:22.030
Pourquoi y en a-t-il autant ?

00:08:22.030 --> 00:08:24.070
Je ne sais même pas par où commencer.

00:08:24.070 --> 00:08:27.060
Parce que même si pour
la plupart d'entre nous qui écoutons

00:08:27.060 --> 00:08:29.490
en ce moment sont probablement
des défenseurs de l'accessibilité et font

00:08:29.490 --> 00:08:32.130
c'est évident, choisissez simplement celui
qui correspond à vos besoins et allez-y.

00:08:32.130 --> 00:08:33.900
Ce n'est pas si évident pour
quelqu'un qui ne sait pas grand chose

00:08:33.900 --> 00:08:34.730
sur l'accessibilité.

00:08:34.730 --> 00:08:38.140
Alors ils le regarderont et diront :
C'est trop, je m'en vais.

00:08:38.140 --> 00:08:40.720
Combien de fois ai-je entendu
quelqu'un dire : "C'est trop ?

00:08:40.720 --> 00:08:43.190
Je ne savais même pas par où
commencer, j'ai juste abandonné.

00:08:43.190 --> 00:08:45.320
C'est beaucoup, croyez-le ou non.

00:08:45.320 --> 00:08:50.110
Nous devons donc prendre une
approche différente pour pouvoir

00:08:50.110 --> 00:08:55.920
faire face à cette surcharge et à
cette perspective négative que nous avons

00:08:55.920 --> 00:08:59.200
que pour les développeurs,
l'accessibilité c'est trop.

00:08:59.200 --> 00:09:01.250
L'accessibilité automatisée
est de trop.

00:09:01.250 --> 00:09:03.840
Alors, quelle est la solution ?

00:09:05.100 --> 00:09:06.990
Vous êtes dans une approche pratique
de l'accessibilité automatique

00:09:06.990 --> 00:09:08.220
alors Mark, dis-moi la solution.

00:09:09.370 --> 00:09:10.560
Il s'agit d'une automatisation progressive.

00:09:11.770 --> 00:09:16.170
J'ai eu énormément
de chance en faisant ça,

00:09:16.170 --> 00:09:19.370
et j'ai de très bons cas d'utilisation
pour faire cela et nous assurer

00:09:19.370 --> 00:09:20.480
qu'on comprend.

00:09:20.480 --> 00:09:26.160
La chose la plus importante quand il est
question d'automatisation qui

00:09:26.160 --> 00:09:31.450
fonctionne bien, c'est le faire correctement
et ça a l'air plutôt drôle,

00:09:31.450 --> 00:09:35.700
mais quand il s'agit de mettre en phase de
l'automatisation, vous pouvez regarder ceci

00:09:35.700 --> 00:09:38.140
et dire : Mark, ça prend trop de temps.

00:09:38.140 --> 00:09:39.150
Oui, tu as parfaitement raison.

00:09:39.150 --> 00:09:40.410
Cela prend du temps.

00:09:40.410 --> 00:09:44.950
Mais si vous faites les choses correctement, cela reste et
cela dure au sein de votre organisation.

00:09:44.950 --> 00:09:46.550
au sein de votre équipe de développement.

00:09:46.550 --> 00:09:50.310
Ainsi, la mise en place par phase garantit que
la surcharge des développeurs ne se produit pas

00:09:51.450 --> 00:09:55.340
et nous construisons une stratégie autour de cela
qui fait partie de la partie de phase

00:09:55.340 --> 00:09:56.190
aussi.

00:09:56.190 --> 00:10:00.170
Il s'agit donc essentiellement de trois
phases avec une phase zéro.

00:10:00.170 --> 00:10:03.310
La première phase concerne le linting, la deuxième phase
concerne les bibliothèques de tests automatisés,

00:10:03.310 --> 00:10:07.880
la phase trois concerne
les tests de régression automatisés et la phase zéro concerne les extensions.

00:10:07.880 --> 00:10:10.710
Je vais éventuellement aborder cette phase zéro et
pourquoi je l'appelle phase zéro durant la

00:10:10.710 --> 00:10:14.200
présentation, mais plongeons-nous
dans le vif du sujet, car c'est

00:10:14.200 --> 00:10:18.100
là où devient vraiment
intéressant et génial.

00:10:18.100 --> 00:10:20.120
Phase 1 du linting.

00:10:20.120 --> 00:10:22.400
Pour ceux d'entre vous qui ne
le savent pas, un linter est un outil

00:10:22.400 --> 00:10:27.440
qui analyse statiquement le code source
pour signaler les erreurs de programmation et les bugs.

00:10:27.440 --> 00:10:31.360
Alors que je développe du contenu,
cela me montrera les erreurs

00:10:31.360 --> 00:10:35.020
que je crée
de manière statique dans mon HTML.

00:10:35.020 --> 00:10:37.880
Certaines personnes l'utilisent pour
JavaScript, Java,

00:10:37.880 --> 00:10:39.890
il existe plusieurs
outils de linting différents

00:10:39.890 --> 00:10:41.410
pour beaucoup de choses différentes.

00:10:41.410 --> 00:10:44.260
Mais c'est un
analyseur statique de code.

00:10:45.460 --> 00:10:47.880
Les avantages du linting en accessibilité.

00:10:47.880 --> 00:10:50.510
Vous pouvez détecter
les problèmes d'accessibilité plus tôt.

00:10:51.550 --> 00:10:54.200
Vous augmentez
les connaissances des développeurs en matière d'accessibilité

00:10:54.200 --> 00:10:56.440
au fur et à mesure de leur développement,
et non plus tard.

00:10:56.440 --> 00:10:59.520
Cela permet aux équipes de créer
des portes accessibles lors de la validation.

00:10:59.520 --> 00:11:03.950
Ce que je veux dire par là, c'est que disons que
je développe avec mon coéquipier,

00:11:03.950 --> 00:11:07.890
Je développe un bout de code, je le pousse
, je peux voir mes erreurs Linting

00:11:07.890 --> 00:11:10.720
et je dois retourner au code et
les réparer, avant d'être autorisé

00:11:10.720 --> 00:11:12.740
à pousser ce code.

00:11:12.740 --> 00:11:17.030
Et ce qui est vraiment génial avec
le linting, c'est qu'il est personnalisable

00:11:17.030 --> 00:11:19.090
au framework
dans lequel vous développez.

00:11:19.090 --> 00:11:20.800
C'est la principale
raison pour laquelle ça marche.

00:11:20.800 --> 00:11:25.120
Oui, le plus gros avantage est le
dernier point là-dessus, la personnalisation

00:11:25.120 --> 00:11:27.440
au framework
dans lequel vous développez.

00:11:27.440 --> 00:11:28.670
C'est ce qui est vraiment cool.

00:11:28.670 --> 00:11:30.650
Quand vous commencez à mettre ça
en place, vous déterminez ce

00:11:30.650 --> 00:11:37.140
qu'utilisent vos équipes,
si elles utilisent React, Angular, Vue ?

00:11:37.140 --> 00:11:40.290
Ou même tout autre type de framework,
vous pouvez l'utiliser en cours de route.

00:11:40.290 --> 00:11:44.000
Et ce qui est vraiment génial, c'est que
pendant que je construis avec Linting,

00:11:44.000 --> 00:11:45.730
Je peux trouver le Linter
qui convient,

00:11:45.730 --> 00:11:47.550
et je vous garantis qu'ils
ont des règles d'accessibilité.

00:11:47.550 --> 00:11:52.050
Je vais vous faire une démonstration de cela
parce que c'est la partie

00:11:52.050 --> 00:11:52.710
que j'aime le plus.

00:11:52.710 --> 00:11:57.840
Je vais passer
très rapidement à notre démonstration de Linting.

00:11:57.840 --> 00:12:03.060
Laisse-moi le trouver.

00:12:03.060 --> 00:12:04.060
Très bien.

00:12:04.970 --> 00:12:08.750
Ce que j'ai ici, c'est
mon joli projet React.

00:12:08.750 --> 00:12:11.160
Je dois donner le contexte
car c'est mon projet préféré

00:12:11.160 --> 00:12:12.190
de tous les temps.

00:12:12.190 --> 00:12:14.160
C'est un magasin de sabres laser.

00:12:14.160 --> 00:12:16.260
Vous achetez donc des sabres laser
sur le site.

00:12:16.260 --> 00:12:19.390
Et donc ce projet React
que j'ai utilisé pour toutes mes

00:12:19.390 --> 00:12:21.330
présentations, je l'ai
fait il y a plusieurs années.

00:12:21.330 --> 00:12:22.700
C'est génial ici.

00:12:22.700 --> 00:12:27.590
Mais dans ce projet, j'ai un
composant, qui est un élément de panier.

00:12:27.590 --> 00:12:30.740
C'est donc juste un objet qui
a essentiellement une image.

00:12:30.740 --> 00:12:34.210
Il y a un titre pour décrire
ce que le produit est,

00:12:34.210 --> 00:12:35.110
une petite description.

00:12:35.110 --> 00:12:39.680
Et puis-je ajouter le clic pour
avoir plus de détails, ou puis-je l'acheter à nouveau ?

00:12:39.680 --> 00:12:40.480
C'est tout.

00:12:40.480 --> 00:12:41.170
Lien simple.

00:12:41.170 --> 00:12:43.820
Pensez comme un article de panier Amazon
où de gauche à droite,

00:12:43.820 --> 00:12:48.750
c'est une description d'image et ensuite
des boutons à l'extrême droite.

00:12:48.750 --> 00:12:55.630
En ce moment, en utilisant React,
j'utilise en fait JSX a11y Linter.

00:12:57.110 --> 00:13:00.560
Ce Linter a spécifiquement
des règles d'accessibilité pour ESLint.

00:13:01.680 --> 00:13:04.580
ESLint est probablement l'un des
Linters les plus populaires

00:13:04.580 --> 00:13:06.760
qui existent actuellement.

00:13:06.760 --> 00:13:09.990
Il y a ici un sous-ensemble
de règles d'accessibilité.

00:13:09.990 --> 00:13:13.740
Disons que je suis développeur
sur ce composant d'élément de panier,

00:13:13.740 --> 00:13:16.600
si je regarde cet écran en ce
moment, ce que j'ai c'est,

00:13:16.600 --> 00:13:21.120
J'ai quelques
lignes rouges ondulées à quelques endroits différents.

00:13:21.120 --> 00:13:25.270
Donc sur la ligne 11 ici, j'ai un div
qui est un conteneur d'image et

00:13:25.270 --> 00:13:28.060
pour une raison quelconque, ce développeur
voulait cacher quelque chose.

00:13:28.060 --> 00:13:29.180
Mais il n'a pas bien vérifié.

00:13:29.180 --> 00:13:31.720
Alors il a dit que aria-hide était égal à vrai.

00:13:31.720 --> 00:13:33.060
Ouais, aria-hide n'est pas vrai.

00:13:33.060 --> 00:13:36.810
Donc si je passe la souris au-dessus
, ça dira aria-hide.

00:13:36.810 --> 00:13:38.030
Ce n'est pas un attribut

00:13:38.030 --> 00:13:39.360
qui est un attribut aria valide.

00:13:39.360 --> 00:13:41.500
Vouliez-vous plutôt utiliser
aria-hidden ou aria-live ?

00:13:41.500 --> 00:13:43.060
Et il vous le dira.

00:13:43.060 --> 00:13:45.230
Alors ce qui est vraiment cool, c'est que
maintenant, si je suis développeur

00:13:45.230 --> 00:13:48.030
qui ne sait vraiment rien, et
disons que j'ai fait une mauvaise recherche

00:13:48.030 --> 00:13:53.340
sur StackOverflow, je peux changer ça
en aria-hidden et voilà,

00:13:53.340 --> 00:13:54.340
la ligne ondulée a disparu.

00:13:55.400 --> 00:13:57.600
C'est du linting pendant que je le fais.

00:13:57.600 --> 00:14:00.540
Cette image,
il me manque un attribut alt.

00:14:00.540 --> 00:14:02.960
Cela me dira que les images doivent
avoir un attribut alt approprié.

00:14:02.960 --> 00:14:05.460
avec un texte significatif ou un
attribut vide pour des images décoratives.

00:14:05.460 --> 00:14:08.970
Eh bien, dans ce cas-ci, je vais
supposer que cette personne avait l'intention

00:14:08.970 --> 00:14:10.700
de masquer ceci en tant qu'image alternative.

00:14:10.700 --> 00:14:13.200
Nous allons donc simplement lui donner un attribut alt et
tout, la ligne ondulée a disparu.

00:14:14.300 --> 00:14:17.370
Cela va même jusqu'à ce que j'ai dit plus tôt
à propos d'appliquer de bonnes pratiques de codage.

00:14:18.660 --> 00:14:19.780
J'utilise une ancre.

00:14:19.780 --> 00:14:23.270
L'attribut href est requis pour qu'une
ancre soit accessible au clavier.

00:14:23.270 --> 00:14:26.300
Salut, combien d'ancres existent
dans la nature en ce moment

00:14:26.300 --> 00:14:29.490
qui sont essentiellement des ancres
sans href.

00:14:29.490 --> 00:14:32.430
Ils ne sont donc pas accessibles au clavier
pour une raison quelconque pour cliquer sur les événements

00:14:32.430 --> 00:14:32.880
de href.

00:14:32.880 --> 00:14:33.070
Pourquoi ?

00:14:33.070 --> 00:14:34.560
Je n'en ai aucune idée.

00:14:35.760 --> 00:14:39.230
Je peux simplement ajouter le href
lui-même là où il doit aller.

00:14:40.520 --> 00:14:43.400
Donc ici href égal et ensuite
je pourrais juste dire détails.

00:14:44.460 --> 00:14:45.460
Oups.

00:14:47.680 --> 00:14:49.330
Et voilà, c'est fait.

00:14:50.540 --> 00:14:51.330
C'est tout.

00:14:51.330 --> 00:14:52.730
C'est ça le Linting.

00:14:52.730 --> 00:14:55.000
C'est aussi simple que cela.

00:14:55.000 --> 00:14:59.410
C'est la solution gagnante la plus simple
pour les équipes de développement.

00:14:59.410 --> 00:15:01.670
Et c'est vraiment aussi simple que cela.

00:15:01.670 --> 00:15:02.030
Oui.

00:15:02.030 --> 00:15:03.170
Vous vous dites peut-être en
regardant cela, Mark,

00:15:03.170 --> 00:15:04.870
Ce sont des problèmes extrêmement simplistes.

00:15:04.870 --> 00:15:05.660
Laissez-moi vous dire ceci.

00:15:05.660 --> 00:15:09.530
Le sondage million WebAIM 
me dit que toutes les choses

00:15:09.530 --> 00:15:12.830
dont nous parlons, en ce qui
concerne la simplicité, devinez quoi ?

00:15:12.830 --> 00:15:15.900
Il y a beaucoup de problèmes simples
qui sont actuellement en production.

00:15:15.900 --> 00:15:17.690
Ils existent sur les pages d'accueil
et partout.

00:15:17.690 --> 00:15:19.020
Alors devinez quoi ?

00:15:19.020 --> 00:15:20.790
Le Linting peut résoudre
ces problèmes simples.

00:15:20.790 --> 00:15:23.040
Si nous mettons en place le bon système
, cela peut résoudre ces problèmes.

00:15:23.040 --> 00:15:25.770
Et c'est vraiment
le Linting en résumé.

00:15:25.770 --> 00:15:27.699
Super simple,
vraiment direct

00:15:27.700 --> 00:15:28.820
pour s'y mettre.

00:15:29.830 --> 00:15:32.980
Et il y a beaucoup de bonnes
choses qui vont avec.

00:15:32.980 --> 00:15:35.090
Il existe
également certaines bonnes pratiques liées au Linting.

00:15:35.090 --> 00:15:38.150
Donc trouver une bibliothèque qui
fonctionne avec votre pile technologique,

00:15:38.150 --> 00:15:41.320
comme je l'ai déjà dit, ESLint
est le plus populaire.

00:15:41.320 --> 00:15:44.660
Il possède le plus grand nombre d'intégrations
qui existent.

00:15:44.660 --> 00:15:45.610
Vous pouvez donc les récupérer.

00:15:45.610 --> 00:15:47.280
Il possède
spécifiquement des bibliothèques d'accessibilité

00:15:47.280 --> 00:15:49.530
quel que soit le framework que
vous utilisez.

00:15:49.530 --> 00:15:51.550
Trouvez un ensemble de règles cohérent.

00:15:51.550 --> 00:15:55.440
Ce qui est génial avec ça, c'est que la plupart des
bibliothèques open source sont couplées

00:15:55.440 --> 00:15:58.320
avec axe-core car c'est la
bibliothèque la plus populaire qui existe.

00:15:58.320 --> 00:16:00.550
Donc si vos équipes
décident d'utiliser axe-core,

00:16:00.550 --> 00:16:02.900
vous pouvez également utiliser l'axe linter.

00:16:02.900 --> 00:16:04.190 
Cela
Celui-ci ne pose aucun problème
.

00:16:04.190 --> 00:16:04.540
Parfait.

00:16:04.540 --> 00:16:05.440
C'est génial.

00:16:05.440 --> 00:16:09.280
Mais le JSX a11y utilise
également certaines des règles d'axe-core.

00:16:09.280 --> 00:16:11.420
La cohérence est donc la clé
parce que vous ne voulez pas

00:16:11.420 --> 00:16:13.850
avoir plusieurs règles différentes
qui soient exécutées en même temps

00:16:13.850 --> 00:16:15.390
où les développeurs se diraient
, je ne comprends pas

00:16:15.390 --> 00:16:18.960
pourquoi c'est un problème ici
et pas un problème là.

00:16:18.960 --> 00:16:21.430
La cohérence est donc la clé.

00:16:21.430 --> 00:16:23.140
Une autre bonne pratique
est de

00:16:23.140 --> 00:16:24.800
forcer le Linting lors de la validation.

00:16:24.800 --> 00:16:25.910
Et puis, construisez vos propres règles.

00:16:25.910 --> 00:16:26.940
Je ne saurais trop insister là-dessus.

00:16:26.940 --> 00:16:29.340
Vous pouvez construire vos propres
règles, croyez-le ou non.

00:16:29.340 --> 00:16:32.500
Vous pouvez créer vos propres règles,
les ajouter dans Linting et faire la vérification

00:16:32.500 --> 00:16:36.060
des éléments que votre équipe de développement
ou que votre organisation souhaite vérifier.

00:16:36.060 --> 00:16:37.840
C'est très, très simple.

00:16:37.840 --> 00:16:41.180
Et ainsi vous pouvez aller un peu plus
loin avec ça.

00:16:41.180 --> 00:16:42.370
C'était donc ça le Linting.

00:16:42.370 --> 00:16:43.480
Première phase.

00:16:43.480 --> 00:16:48.340
Et encore une fois, permettez-moi de répéter que toutes ces
phases prennent le temps qu'elles prennent.

00:16:48.340 --> 00:16:52.420
Cela ne veut pas dire que la
première phase est un sprint. Absolument pas.

00:16:52.420 --> 00:16:55.720
C'est possible que la première phase
prenne trois mois pour démarrer

00:16:55.720 --> 00:16:58.150
et fonctionne correctement avec tout
ce dont nous parlons ici

00:16:58.150 --> 00:17:00.010
pour les meilleures pratiques et
peut-être d'autres choses

00:17:00.010 --> 00:17:02.810
que votre organisation
ou votre équipe de développement souhaite faire.

00:17:02.810 --> 00:17:04.290
Cela peut prendre du temps.

00:17:04.290 --> 00:17:05.540
Ce n'est pas grave.

00:17:05.540 --> 00:17:06.900
Laissez-le prendre du temps.

00:17:06.900 --> 00:17:10.860
Nous voulons que cela prenne du temps parce que
nous devons bien faire les choses, d'accord ?

00:17:10.860 --> 00:17:14.360
Donc une fois la première phase terminée,
on passe à la phase deux,

00:17:14.360 --> 00:17:16.310
qui sont
les bibliothèques d'accessibilité automatisée.

00:17:16.310 --> 00:17:19.480
Et la plupart des gens ici qui
sont probablement des développeurs

00:17:19.480 --> 00:17:22.700
ou des personnes qui effectuent de véritables tests
ou qui construisent des bibliothèques de tests

00:17:22.700 --> 00:17:25.300
connaissent probablement certaines des
bibliothèques d'accessibilité automatisées

00:17:25.300 --> 00:17:26.300
qui existent.

00:17:27.560 --> 00:17:30.560 
Les bibliothèques d'accessibilité automatisées
ont des contrôles intégrés

00:17:30.560 --> 00:17:33.760
qui analysent le contenu de votre interface utilisateur
pour détecter les problèmes d'accessibilité.

00:17:33.760 --> 00:17:38.590
Par exemple, si j'ai un
projet de pilote Web Selenium

00:17:38.590 --> 00:17:41.260
ou un projet Puppeteer,
vous pouvez nommer n'importe quel type

00:17:41.260 --> 00:17:45.310
de système que vous utilisez
, je peux ajouter cette bibliothèque.

00:17:45.310 --> 00:17:47.180
Il s'intègre au
framework de test que j'utilise.

00:17:47.180 --> 00:17:51.980
Et je crée un cas de test qui vérifie
s'il y a des problèmes

00:17:51.980 --> 00:17:54.980
dans la page ou le
contenu que je scanne.

00:17:54.980 --> 00:17:56.770
Encore une fois, il s'agit d'une vérification générique.

00:17:56.770 --> 00:17:59.490
Ce n'est pas quelque chose qui va
spécifiquement entrer

00:17:59.490 --> 00:18:02.670
et modifier votre contenu,
comme ouvrir, développer, réduire des sections,

00:18:02.670 --> 00:18:04.830
effectuer tout type d'actions accessibles.

00:18:04.830 --> 00:18:06.250
Il
analysera simplement votre contenu de manière générique.

00:18:06.250 --> 00:18:09.590
Maintenant, ça fait plus que
du Linting parce qu'il peut faire plus

00:18:09.590 --> 00:18:12.420
qu'une simple analyse statique
car la page entièrement rendue

00:18:12.420 --> 00:18:15.560
ou le composant entièrement rendu
est disponible à ce moment-là.

00:18:15.560 --> 00:18:20.230
Mais l'avantage de ces bibliothèques
réside dans leurs ensembles de règles cohérentes.

00:18:20.230 --> 00:18:21.220
C'est le plus important.

00:18:21.220 --> 00:18:24.800
C'est un ensemble cohérent de
règles qui s'appliquent encore et encore

00:18:24.800 --> 00:18:25.840
sur ce contenu.

00:18:25.840 --> 00:18:31.290
Donc si je fais un ou deux
scénarios de test, un pour ma page d'accueil

00:18:31.290 --> 00:18:34.780
et un pour ma page de connexion,
le même ensemble de règles s'exécute

00:18:34.780 --> 00:18:35.420
sur les deux.

00:18:35.420 --> 00:18:39.240
J'obtiens donc des résultats
et des analyses cohérents.

00:18:39.240 --> 00:18:42.160
Je peux à nouveau construire des portes,
ce qui est génial quand je dis portes,

00:18:42.160 --> 00:18:46.940
quand je pousse du code pour,
disons, un PR dans GitHub

00:18:46.940 --> 00:18:51.510
ou j'envoie du code pour révision de code
ou je l'envoie en production.

00:18:51.510 --> 00:18:53.100
Je peux mettre une porte là-dessus
et dire que je m'attends à ce

00:18:53.100 --> 00:18:55.030
qu'il n'y ait aucune violation d'accessibilité.

00:18:55.030 --> 00:18:59.600
Et c'est rapide et facile à ajouter à
la structure actuelle de test de l'interface utilisateur.

00:19:00.940 --> 00:19:02.680
Vous dites probablement : Eh bien,
Mark, vous avez dit que c'était rapide et facile.

00:19:02.680 --> 00:19:04.630
pour le Linting,
le Linting est encore plus rapide.

00:19:04.630 --> 00:19:11.290
Ceci reste simple à ajouter
dans un processus de test d'interface utilisateur.

00:19:11.290 --> 00:19:14.150
La différence est que lorsque vous
faites cela, cela prend un peu de temps

00:19:14.150 --> 00:19:15.890
de travail pour mettre cela en place
initialement, ce qui est

00:19:15.890 --> 00:19:19.140
là où se situeront les réticences
, si jamais vous en arrivez là.

00:19:19.140 --> 00:19:20.370
Eh bien, cela va prendre du temps.

00:19:20.370 --> 00:19:21.340
Ce sera le cas.

00:19:21.340 --> 00:19:25.440
Mais je vais vous montrer à quel point
il peut être simple de configurer cela

00:19:25.440 --> 00:19:28.760
d'une manière qui est répétable
et relativement simple

00:19:28.760 --> 00:19:29.290
à construire.

00:19:29.290 --> 00:19:30.060
D'accord.

00:19:30.060 --> 00:19:36.690
Je vais donc revenir directement à
mon charmant magasin de sabres laser.

00:19:36.690 --> 00:19:42.223
Et ce que je vais faire
, c'est que je vais aller

00:19:42.224 --> 00:19:44.520
dans l'une de mes spécifications.

00:19:44.520 --> 00:19:45.910
Cette spécification est donc mon cas de test ici.

00:19:46.970 --> 00:19:51.550
Ma première spécification ici est en fait
juste un test, laisse-moi y aller

00:19:51.550 --> 00:19:55.880
dans ma spécification de pied de page. En fait, il s'agit
simplement de tester mon composant de pied de page

00:19:55.880 --> 00:19:57.680
pour mon application.

00:19:57.680 --> 00:20:00.210
Donc encore une fois, ces
bibliothèques de tests d'accessibilité peuvent fonctionner

00:20:00.210 --> 00:20:01.030
à plusieurs niveaux.

00:20:01.030 --> 00:20:04.420
Cela peut fonctionner dans le cadre d'un test unitaire,
qui serait comme chaque composant,

00:20:04.420 --> 00:20:06.106
ou peut fonctionner dans un
test de niveau d'intégration,

00:20:06.107 --> 00:20:08.740
qui représente tout ce qui est rassemblé
à l'écran.

00:20:08.740 --> 00:20:11.840
Quelle que soit la méthode qui convient à votre
équipe, c'est ainsi que vous pouvez le faire.

00:20:11.840 --> 00:20:14.840
C'est un bel aspect des
bibliothèques d'accessibilité automatisées.

00:20:14.840 --> 00:20:21.310
Donc, avec cette spécification de pied de page, ce que j'ai,
c'est que j'utilise une bibliothèque de tests en React

00:20:21.310 --> 00:20:24.830
pour cela, et dans ce cas, j'ai mis en place
plusieurs cas de test juste pour vérifier.

00:20:24.830 --> 00:20:27.470
Par exemple, j'ai un
test qui vérifie simplement

00:20:27.470 --> 00:20:29.870
si un composant se charge,
j'ai une validation pour dire,

00:20:29.870 --> 00:20:32.120
il devrait y avoir un certain
nombre de listes d'éléments

00:20:32.120 --> 00:20:33.790
qui sont dans le pied de page,
donc j'ai une liste de liens

00:20:33.790 --> 00:20:34.790
en bas.

00:20:35.610 --> 00:20:40.380
Et en plus de ça,
j'ajoute un test.

00:20:40.380 --> 00:20:42.763
Vous pouvez appeler cette
vérification d'accessibilité,

00:20:42.764 --> 00:20:44.840
vous pourriez appeler cela estAccessible,

00:20:44.840 --> 00:20:46.360
tu peux l'appeler
comme tu veux.

00:20:46.360 --> 00:20:48.470
Le nommer de manière cohérente est la clé.

00:20:48.470 --> 00:20:50.280
Parce que quand je nommerai mes
choses, je dirai

00:20:50.280 --> 00:20:53.130 
vérification de l'accessibilité
des composants de pied de page.

00:20:53.130 --> 00:20:56.870
Ce qui est génial c'est que, comme je construis
ça avec une bibliothèque d'accessibilité,

00:20:56.870 --> 00:20:59.780
celui-ci, j'utilise axe-core
pour mes deux exemples.

00:20:59.780 --> 00:21:01.520
C'est probablement le
plus simple à intégrer

00:21:01.520 --> 00:21:04.140
et il a le plus d'intégrations.

00:21:04.140 --> 00:21:11.000
Mais au fur et à mesure que je développe cela,
je peux simplement faire le même scénario de test

00:21:11.000 --> 00:21:13.950
sur plusieurs spécifications.

00:21:13.950 --> 00:21:15.470
C'est ce
qui est beau dans tout ça.

00:21:15.470 --> 00:21:18.470
Je peux réellement le créer et
le rendre cohérent par rapport à l'endroit où

00:21:18.470 --> 00:21:23.860
quand j'intègre ça,
c'est littéralement du copier-coller.

00:21:23.860 --> 00:21:24.450
C'est simple.

00:21:24.450 --> 00:21:26.050
Je vais vous montrer comment.

00:21:26.050 --> 00:21:28.710
Donc cette vérification d'accessibilité
que j'ai ici.

00:21:28.710 --> 00:21:30.510
Ceci est spécifique à
la bibliothèque de tests React,

00:21:30.510 --> 00:21:33.790
mais essentiellement je prends le
conteneur qui contient le composant,

00:21:33.790 --> 00:21:37.500
J'affiche mon pied de page,
je lance ensuite axe.run,

00:21:37.500 --> 00:21:40.400
ce qui est la manière typique d'
exécuter Axe sur le conteneur.

00:21:40.400 --> 00:21:43.710
Alors maintenant, je vais appliquer les
règles d'axe-core dessus.

00:21:43.710 --> 00:21:45.810
J'ai ce rapporteur personnalisé
qui est ici, si vous voulez

00:21:45.810 --> 00:21:48.630
avoir un rapporteur, c'est
possible, mais pas nécessaire.

00:21:48.630 --> 00:21:53.640
Et puis je m'attends à...
[Inaudible 21:54]

00:21:53.640 --> 00:21:56.360
results.violations, qui correspond
à la violation du composant,

00:21:56.360 --> 00:21:59.130
Je m'attends à
ce que la longueur soit à zéro.

00:22:00.370 --> 00:22:01.710
C'est tout.

00:22:01.710 --> 00:22:03.050
Et c'est tout.

00:22:03.050 --> 00:22:08.610
Ce qui est vraiment génial, c'est
que je peux maintenant prendre ça, le copier,

00:22:08.610 --> 00:22:09.570
et devinez quoi ?

00:22:09.570 --> 00:22:11.070
Laisse-moi juste en trouver
un autre très rapidement.

00:22:11.070 --> 00:22:12.250
pour que vous puissiez tous le voir.

00:22:12.250 --> 00:22:13.600
Si je relevais mon composant d'en-tête.

00:22:15.220 --> 00:22:16.560
Regardez ça.

00:22:16.560 --> 00:22:18.390
Littéralement exactement pareil.

00:22:18.390 --> 00:22:21.020
La seule différence pourrait être
que nous changions le nom

00:22:21.020 --> 00:22:23.260
si vous avez un enregistrement
ou des choses comme ça.

00:22:23.260 --> 00:22:24.190
Mais c'est tout.

00:22:24.190 --> 00:22:26.050
C'est aussi simple que cela.

00:22:26.050 --> 00:22:30.110
Un copier-coller de ce
cas de test si nous le configurons correctement.

00:22:30.110 --> 00:22:32.960
Si vos cas de test sont correctement configurés
, c'est aussi simple que cela.

00:22:32.960 --> 00:22:35.730
Souvent, lorsque les équipes mettent en place
ces bibliothèques de tests avec succès

00:22:35.730 --> 00:22:38.670
ils disent, Mark,
c'est tellement de travail à faire.

00:22:38.670 --> 00:22:40.050
Ce n'est vraiment pas le cas.

00:22:40.050 --> 00:22:42.270
C'est aussi simple que de configurer
correctement votre cas de test

00:22:42.270 --> 00:22:45.960
sur une chose, s'assurer que cela
fonctionne et ensuite l'exécuter.

00:22:45.960 --> 00:22:46.760
C'est simple.

00:22:46.760 --> 00:22:50.330
Je peux donc
également exécuter cela très rapidement, juste la spécification du pied de page.

00:22:50.330 --> 00:22:53.530
Laissez-moi exécuter ça.

00:22:53.530 --> 00:22:57.340
Maintenant, je vous préviens, car à chaque fois que
je finis par lancer quelque chose comme ça

00:22:57.340 --> 00:22:59.170
lors d'une démo live,
surtout tôt le matin,

00:22:59.170 --> 00:23:00.920
mon ordinateur n'a toujours
pas eu son café.

00:23:00.920 --> 00:23:02.740
Je suis donc sûr que ce sera
probablement juste comme,

00:23:02.740 --> 00:23:05.110
Je n'ai pas envie de travailler en
ce moment, ce qui est bien.

00:23:05.110 --> 00:23:08.310
Je peux simplement passer à ma
partie suivante après cela si j'en ai besoin.

00:23:08.310 --> 00:23:12.980
Mais pendant que cela roule, ce que je veux
montrer, c'est à quel point c'est simple

00:23:12.980 --> 00:23:15.960
pour voir les résultats qui
en découlent également.

00:23:15.960 --> 00:23:19.390
Donc si j'ai fini avec le
composant, disons que j'ai fini

00:23:19.390 --> 00:23:21.780
avec mes règles de linting, je dis que
c'est bon, et je dis,

00:23:21.780 --> 00:23:24.450
oui, je vais exécuter mon
cas de test contre cela.

00:23:24.450 --> 00:23:27.650
Eh bien, ce que je peux faire maintenant, c'est
soit avoir un rapporteur, soit le faire

00:23:27.650 --> 00:23:29.760
dans la console,
qui est fournie avec la plupart

00:23:29.760 --> 00:23:33.280
des bibliothèques de tests dont vous disposez, pour
dire, où sont les problèmes existants ?

00:23:33.280 --> 00:23:35.380
Je vais donc trouver mon pied de page.

00:23:35.380 --> 00:23:36.620
Oh, oui,
nous avons beaucoup de problèmes ici.

00:23:37.650 --> 00:23:40.190
Apparemment, Mark devrait mettre à jour
ses choses car elles sont obsolètes.

00:23:40.190 --> 00:23:41.380
Voilà mon pied de page.

00:23:41.380 --> 00:23:42.820
Voilà mon cas de test.

00:23:42.820 --> 00:23:45.880
Je m'attendais à ce que results.violation.length
soit nul.

00:23:45.880 --> 00:23:47.570
J'ai trouvé deux problèmes d'accessibilité.

00:23:47.570 --> 00:23:50.060
Eh bien, puisque j'ai un
rapporteur client, je peux simplement aller

00:23:50.060 --> 00:23:51.400
là-dedans très vite et
découvrir quelles sont mes erreurs.

00:23:51.400 --> 00:23:52.820
Oh, regarde ça.

00:23:52.820 --> 00:23:54.730
Les éléments de formulaire n'ont pas d'étiquette.

00:23:54.730 --> 00:23:56.110
Génial.

00:23:56.110 --> 00:23:56.690
Même chose.

00:23:56.690 --> 00:23:58.170
Deux éléments de formulaire
n'ont pas d'étiquette.

00:23:58.170 --> 00:24:02.110
Et, oh, ma liste est incluse
dans les HR au milieu de ma liste.

00:24:02.110 --> 00:24:04.390
C'est simple.

00:24:04.390 --> 00:24:06.150
Donc ces choses peuvent être
attrapées en cours de route.

00:24:06.150 --> 00:24:08.100
Et maintenant je peux prendre
ce même cas de test

00:24:08.101 --> 00:24:09.850
et le reproduire à tous les niveaux.

00:24:11.170 --> 00:24:12.170
C'est simple.

00:24:12.860 --> 00:24:14.630
Si vous le regardez
du point de vue de l'intégration,

00:24:14.630 --> 00:24:19.770
juste comme une présentation rapide, j'ai aussi
un exemple ici avec Selenium.

00:24:19.770 --> 00:24:23.140
Encore une fois, vous trouvez simplement l'
intégration axe que vous souhaitez.

00:24:23.140 --> 00:24:24.830
axe-webdriverjs.

00:24:24.830 --> 00:24:27.480
Il s'adapte à tout ce que vous
utilisez, le pilote lui-même

00:24:27.480 --> 00:24:29.030
pour les instructions de configuration.

00:24:29.030 --> 00:24:31.620
J'ai tous mes cas de test,
le nombre total de listes,

00:24:31.620 --> 00:24:32.780
liste des boutons rendus.

00:24:32.780 --> 00:24:36.110
Et puis je teste, par
exemple, si c'est accessible.

00:24:36.110 --> 00:24:37.230
Devinez quoi ?

00:24:37.230 --> 00:24:40.150
Ceci juste là est
exactement le même cas de test

00:24:40.150 --> 00:24:43.840
dans tous mes tests d'intégration
car mes cas de test sont configurés

00:24:43.840 --> 00:24:48.680
d'une certaine manière, quand ils sont rendus
, cela dira,

00:24:48.680 --> 00:24:55.010
La page est accessible lors de
l'exécution du test. C'est simple.

00:24:55.010 --> 00:24:59.560
L'utilisation de bibliothèques de tests automatisés
peut donc sembler une tâche ardue,

00:24:59.560 --> 00:25:00.420
mais ce n'est vraiment pas le cas.

00:25:00.420 --> 00:25:04.100
Une fois configuré et opérationnel,
il répète les mêmes tests.

00:25:04.100 --> 00:25:06.180
dans une structure et d'une manière
qui correspond à ce que vous faites.

00:25:06.180 --> 00:25:08.110
Mon exemple est très simpliste.

00:25:08.110 --> 00:25:09.320
Je comprends tout à fait ça.

00:25:09.320 --> 00:25:11.430
Mais pour l'essentiel,
c'est comme ça que ça marche,

00:25:11.430 --> 00:25:13.830
c'est que vous pouvez de manière simpliste
prendre le même cas de test

00:25:13.830 --> 00:25:15.870
et l'exécutez encore et encore.

00:25:15.870 --> 00:25:17.540
Et il vous donne les résultats
en fonction de la façon dont vous avez

00:25:17.540 --> 00:25:18.490
vos cas de test structurés.

00:25:18.490 --> 00:25:23.170
Et c'est au
niveau de l'unité ou de l'intégration, ce qui est fantastique.

00:25:23.170 --> 00:25:27.700
Revenons donc à mes
adorables avantages pour ceux-ci.

00:25:29.390 --> 00:25:33.610
La meilleure pratique pour cela est
de trouver une intégration qui convient

00:25:33.610 --> 00:25:35.380 
à ce que fait
votre équipe de développement.

00:25:35.380 --> 00:25:37.260
Assurez-vous que les règles
sont cohérentes.

00:25:37.260 --> 00:25:41.500
Vous ne voulez pas utiliser de linting qui
utilise une bibliothèque entièrement différente

00:25:41.500 --> 00:25:44.230
que celle de axe, ou vous ne voulez pas
utiliser Pali à un moment donné

00:25:44.230 --> 00:25:47.580
ou un autre ensemble de
tests d'intégration avec celui-ci.

00:25:47.580 --> 00:25:50.340
La plupart des
intégrations open source utilisent de toute façon axe-core,

00:25:50.340 --> 00:25:54.030
ce n'est donc pas un test difficile à
faire, mais assurez-vous que nous en utilisons un

00:25:54.030 --> 00:25:58.160
qui correspond à la
structure de test de l'interface utilisateur que nous réalisons.

00:25:58.160 --> 00:26:00.760
Une autre bonne pratique consiste à s'appuyer
sur le principe un-à-un.

00:26:00.760 --> 00:26:04.210
Il existe un principe un-à-un dans
les tests d'interface utilisateur qui dit que pour chaque élément

00:26:04.210 --> 00:26:08.440
de l'interface, il existe un
cas de test d'accessibilité associé.

00:26:08.440 --> 00:26:11.090
Donc, qu'il s'agisse d'un composant,
d'une page,

00:26:11.090 --> 00:26:15.230
un-à-un nous nous assurons que ce
morceau de code, ce morceau

00:26:15.230 --> 00:26:17.940
d'interface est
associé à un test d'accessibilité.

00:26:17.940 --> 00:26:20.420
Et également tester à
plusieurs niveaux de test.

00:26:20.420 --> 00:26:23.980
Je viens de vous montrer tout
cela, mais si vous pouvez tester

00:26:23.980 --> 00:26:27.590
avec une bibliothèque d'accessibilité au
niveau de l'unité et de l'intégration,

00:26:27.590 --> 00:26:28.680
c'est fantastique.

00:26:28.680 --> 00:26:30.990
C'est gagnant-gagnant à tous les niveaux.

00:26:30.990 --> 00:26:32.120
Vous obtenez tous les
avantages et tout.

00:26:32.120 --> 00:26:34.850
Donc, si vous le pouvez,
testez à plusieurs niveaux de tests.

00:26:35.930 --> 00:26:40.580
Donc la première phase, le linting, la
deuxième phase, les bibliothèques d'accessibilité.

00:26:40.580 --> 00:26:41.900
Vous allez dire : à
Mark, c'est quoi la phase trois ?

00:26:41.900 --> 00:26:44.570
Parce qu'il semble que nous ayons vu toutes
les méthodes d'automatisation de l'accessibilité

00:26:44.570 --> 00:26:45.570
que nous pouvons faire.

00:26:45.990 --> 00:26:47.050
Tada.

00:26:47.050 --> 00:26:48.050
Test de régression.

00:26:49.030 --> 00:26:52.740
Donc j'ai toujours tendance à prendre
souvent des critiques pour ça.

00:26:52.740 --> 00:26:56.010
parce que chaque fois que quelqu'un entend
qu'il est possible d'automatiser encore plus que

00:26:56.010 --> 00:26:59.050
ce que les bibliothèques d'accessibilité
de linting font, les gens ont tendance à

00:26:59.050 --> 00:27:02.740
sauter là-dessus tout de suite et
dire, oh, genre, non, tu ne peux pas.

00:27:02.740 --> 00:27:04.970
Vous parlez d'
automatiser tout avec ça.

00:27:04.970 --> 00:27:06.030
Je ne le suis pas.

00:27:06.030 --> 00:27:08.900
Ce dont je parle,
c'est que vous pouvez créer des cas de test d'interface utilisateur

00:27:08.900 --> 00:27:13.150
qui vont au-delà des simples
bibliothèques d'accessibilité génériques.

00:27:13.150 --> 00:27:17.040
Vous pouvez créer des cas de test automatisés
qui garantissent que la fonctionnalité

00:27:17.040 --> 00:27:19.580
de votre contenu est accessible.

00:27:19.580 --> 00:27:21.780
Par exemple,
une section développer/réduire.

00:27:22.860 --> 00:27:25.640
En utilisant quelque chose comme axe-core
linting, cela va simplement garantir

00:27:25.640 --> 00:27:30.830
que vous avez déjà développé est égal à
faux ou vrai correctement épelé

00:27:30.830 --> 00:27:32.920
et mis ici comme un attribut.

00:27:32.920 --> 00:27:37.990
Il ne peut pas tester la fonctionnalité pour vérifier que
cet état est correctement défini,

00:27:37.990 --> 00:27:40.810
que déjà caché est égal à
vrai est correctement défini

00:27:40.810 --> 00:27:42.950
lorsque vous ouvrez la
section Développer et réduire.

00:27:42.950 --> 00:27:44.390
Il ne peut pas faire ça.

00:27:44.390 --> 00:27:47.340
Les avantages des
tests de régression sont donc les suivants :

00:27:47.340 --> 00:27:49.450
il est plus facile de déboguer
les problèmes d'accessibilité.

00:27:54.090 --> 00:27:58.200
C'est plus facile de faire ça.

00:27:58.200 --> 00:28:00.860
Cela inclut le test d'accessibilité
dans le cadre de votre définition de ce qui est terminé.

00:28:00.860 --> 00:28:05.360
Ainsi, par exemple, nous nous
appuyons en fait sur des audits manuels avec cela.

00:28:05.360 --> 00:28:09.030
Donc, si je reçois un audit manuel qui
dit, Hé, je suis en mesure d'accéder

00:28:09.030 --> 00:28:12.590
à ce contenu dans cette
section développée/réduite lorsqu'il est masqué,

00:28:12.590 --> 00:28:13.260
devinez ce que je peux faire ?

00:28:13.260 --> 00:28:16.200
Je peux écrire un test de régression qui
dit, je dois m'assurer que l'état

00:28:16.200 --> 00:28:19.420
de cet attribut fonctionne
comme je l'attends.

00:28:19.420 --> 00:28:21.587
Est-ce qu'il vérifie
qu'il annonce correctement

00:28:21.588 --> 00:28:22.540
avec un lecteur d'écran ?

00:28:22.540 --> 00:28:25.760
Non, il s'agit simplement de garantir
que le contenu accessible

00:28:25.760 --> 00:28:28.810
ou la fonctionnalité accessible de
ce composant fonctionne correctement.

00:28:28.810 --> 00:28:30.980
Il y a une différence
entre les deux.

00:28:30.980 --> 00:28:33.260
Parce que oui,
il pourrait y avoir des bugs qui existent

00:28:33.260 --> 00:28:35.500
dans les
lecteurs d'écran eux-mêmes.

00:28:35.500 --> 00:28:37.870
Il pourrait y avoir des bugs qui existent
dans notre propre code.

00:28:37.870 --> 00:28:41.030
Mais nous pourrons alors déboguer cela plus facilement.

00:28:41.030 --> 00:28:43.360
Nous nous assurons donc que le
contenu soit entièrement accessible

00:28:43.360 --> 00:28:44.460
d'un point de vue fonctionnel.

00:28:45.500 --> 00:28:47.860
Laissez-moi vous faire une démo
parce qu'à chaque fois que je tends

00:28:47.860 --> 00:28:49.610
à faire ça, tout le monde a tendance
à rester simplement là

00:28:49.610 --> 00:28:51.690
et dire : Je ne crois pas ce que
Mark me dit en ce moment.

00:28:51.690 --> 00:28:52.690
Et c'est très bien.

00:28:54.300 --> 00:28:55.590
Laissez-moi vous donner un exemple.

00:28:56.640 --> 00:28:59.200
C'est donc un
projet Cypress que j'ai.

00:28:59.200 --> 00:29:02.450
Cypress n'est qu'une des
bibliothèques de tests d'interface utilisateur les plus populaires.

00:29:02.450 --> 00:29:03.620
Cela fonctionne relativement de la même manière.

00:29:03.620 --> 00:29:04.600
C'est un testeur d'intégration.

00:29:04.600 --> 00:29:08.840
Mais je veux présenter quelques
exemples de cas de test que nous pouvons réaliser

00:29:08.840 --> 00:29:10.110
d'un point de vue de régression.

00:29:10.110 --> 00:29:14.550
Disons que je reçois un audit manuel
qui dit : Eh bien, l'état désactivé

00:29:14.550 --> 00:29:17.220
de votre bouton n'est pas là.

00:29:17.220 --> 00:29:19.650
Ça change de couleur,
mais ce n'est pas là.

00:29:19.650 --> 00:29:21.670
L'attribut désactivé n'est
en fait pas là.

00:29:21.670 --> 00:29:23.730
Je peux écrire un
test de régression pour ça.

00:29:23.730 --> 00:29:26.030
J'ai donc un cas de test
à l'écran qui dit :

00:29:26.030 --> 00:29:29.010
L'état désactivé
d'un bouton d'offre est-il approprié.

00:29:30.190 --> 00:29:35.790
Je vérifie donc avant de saisir
des informations dans ce champ,

00:29:35.790 --> 00:29:37.080
ce bouton est-il désactivé ?

00:29:37.080 --> 00:29:38.160
Et cela devrait-il exister ?

00:29:38.160 --> 00:29:39.160
Oui ou non ?

00:29:39.990 --> 00:29:41.290
Super.

00:29:41.290 --> 00:29:42.210
Ensuite, j'attends.

00:29:42.210 --> 00:29:45.150
Je tape du contenu dans le champ.

00:29:45.150 --> 00:29:47.740
Dans ce cas, je tape,
j'aime l'accessibilité.

00:29:47.740 --> 00:29:51.720
Je reviens ensuite à ce
bouton désactivé, j'invoque l'attribut désactivé

00:29:51.720 --> 00:29:53.350
et dire qu'il ne devrait pas exister.

00:29:53.350 --> 00:29:55.990
Voilà, c'est fait,
fonctionnalités accessibles en place.

00:29:57.180 --> 00:29:58.180
Très simple.

00:29:58.950 --> 00:30:02.790
La même chose dont nous avons parlé avant,
vérifier la réduction d'aria-expanded.

00:30:02.790 --> 00:30:05.570
J'adore utiliser celui-ci
car c'est un excellent cas d'utilisation.

00:30:05.570 --> 00:30:06.990
J'ai un bouton bascule.

00:30:06.990 --> 00:30:10.790
Je vérifie si aria-expanded par
défaut lorsqu'il est fermé est égal

00:30:10.790 --> 00:30:12.230
à faux.

00:30:12.230 --> 00:30:13.630
Je passe ensuite au scénario de test.

00:30:13.630 --> 00:30:17.950
Je dis, Hé, bascule, déclenche, clique
ou appuie. Je sais que c'est sur celui-là.

00:30:17.950 --> 00:30:20.320
Il n'a pas de clavier
mais je le déclenche.

00:30:21.420 --> 00:30:24.540
J'y vais et j'invoque pour voir
que aria-expanded devrait être vrai.

00:30:24.540 --> 00:30:25.860
Ce n'est pas le cas.

00:30:25.860 --> 00:30:29.040
Je le referme ensuite et
vérifie s'il dit faux.

00:30:29.040 --> 00:30:31.600
Test de régression, relativement
simple et direct.

00:30:33.260 --> 00:30:36.740
Je peux vérifier s'il y a
des indicateurs de focus sur les éléments réels.

00:30:36.740 --> 00:30:38.430
Oui, tu peux le faire.

00:30:38.430 --> 00:30:40.870
Je ferai une mise en garde avec ceci.

00:30:40.870 --> 00:30:45.650
Vous devez
cependant savoir quelle est la couleur du contour de l'indicateur de mise au point,

00:30:45.650 --> 00:30:46.230
pour faire ça.

00:30:46.230 --> 00:30:47.630
Vous ne pouvez pas
vérifier cela de manière générique.

00:30:47.630 --> 00:30:48.950
Donc vous devez savoir ce que c'est.

00:30:48.950 --> 00:30:53.200
Donc, en gros, j'accède à chacun de
ces boutons qui se trouvent dans une liste de menus

00:30:53.200 --> 00:30:56.550
et je me concentre sur eux,
je peux voir le contour CSS.

00:30:56.550 --> 00:30:58.970
Si je sais que la
couleur d'arrière-plan est supposée

00:30:58.970 --> 00:31:01.070
correspondre à une couleur spécifique
, devinez quoi ?

00:31:01.070 --> 00:31:02.370
Il dispose d'un indicateur de focus.

00:31:02.370 --> 00:31:04.700
Combien de sites
connaissez-vous qui régressent

00:31:04.700 --> 00:31:07.820
et retirent leur
indicateur de focus parce qu'ils ne savent pas ?

00:31:07.820 --> 00:31:08.560
Des tonnes.

00:31:08.560 --> 00:31:09.910
Cela peut résoudre ce problème.

00:31:09.910 --> 00:31:13.560
Si vous le savez, assurez-vous que tout votre
contenu réel dispose d'un indicateur de focus.

00:31:14.630 --> 00:31:15.900
A11y se concentre sur les fenêtres modales.

00:31:15.900 --> 00:31:19.940
Combien de modales connaissez-vous tous
qui ne définissent pas correctement le focus

00:31:19.940 --> 00:31:22.830
dans les tonnes modales.

00:31:22.830 --> 00:31:24.270
Cela peut résoudre ce problème.

00:31:24.270 --> 00:31:26.960
Si j'ai des fenêtres modales, je peux écrire
des tests de régression qui garantissent que

00:31:26.960 --> 00:31:31.480
lorsque je déclenche un événement de clic, le
focus passe sur ou dans la modale.

00:31:31.480 --> 00:31:33.850
Dans ce cas, je vérifie juste pour
m'assurer qu'il va bien au titre.

00:31:33.850 --> 00:31:38.330
Quand je le ferme, le focus revient
sur le déclencheur qui l'a fait.

00:31:38.330 --> 00:31:39.040
Vous pouvez le faire.

00:31:39.040 --> 00:31:40.610
Vous pouvez écrire
des tests de régression pour ceux-là.

00:31:41.940 --> 00:31:44.910
C'est la beauté des
tests de régression accessibles.

00:31:44.910 --> 00:31:47.820
Oui,
il faudra du temps pour arriver à cet état.

00:31:47.820 --> 00:31:51.020
Phase un, phase deux, vous pouvez
y arriver assez facilement.

00:31:51.020 --> 00:31:52.280
Cela pourrait prendre un certain temps.

00:31:52.280 --> 00:31:53.510
La phase trois peut prendre un peu de temps.

00:31:53.510 --> 00:31:58.650
Mais je peux vous dire tout de suite
que j'ai vu quelques équipes arriver

00:31:58.650 --> 00:31:59.570
à cette phase trois.

00:31:59.570 --> 00:32:03.200
Et quand ils le font,
si quelque chose régresse,

00:32:03.200 --> 00:32:05.980
si quelque chose est retiré,
quelque chose n'est accidentellement pas fusionné

00:32:05.980 --> 00:32:06.800
dans le code.

00:32:06.800 --> 00:32:10.930
Ils le voient instantanément et
ils évitent des tonnes de plaintes

00:32:10.930 --> 00:32:13.500
de clients disant : Hé,
votre contenu est inaccessible.

00:32:13.500 --> 00:32:16.030
Ils évitent des tonnes de
cotes manuelles qui arrivent en disant, par exemple,

00:32:16.030 --> 00:32:18.960
Hé, ce contenu continue
de se briser, pourquoi n'y en a-t-il pas ?

00:32:18.960 --> 00:32:20.610
Cela peut aider à résoudre ce problème.

00:32:20.610 --> 00:32:23.490
Oui, nous ne vérifions pas quelle
est la sortie du lecteur d'écran.

00:32:23.490 --> 00:32:25.590
Nous vérifions simplement
que le contenu

00:32:25.590 --> 00:32:27.790
est accessible en termes de fonctionnalités.

00:32:27.790 --> 00:32:31.060
Et cela peut grandement contribuer à
faciliter la tâche de tout le monde

00:32:31.060 --> 00:32:33.000
pour voir cela,
et pour que les équipes de développement puissent déboguer.

00:32:33.000 --> 00:32:38.310
C'est un excellent moyen d'adhérer et
d'inciter davantage de personnes à adhérer.

00:32:38.310 --> 00:32:40.850
Donc les meilleures pratiques pour cela.

00:32:40.850 --> 00:32:45.630
Je suis sûr que les tests de régression sont
correctement étiquetés dans vos tests d'interface utilisateur.

00:32:45.630 --> 00:32:48.890
Utilisez donc A11y ou Accessibilité
dans les tests afin que vous sachiez

00:32:48.890 --> 00:32:51.220
qu'il s'agit d'un
test de régression d'accessibilité.

00:32:51.220 --> 00:32:53.780
Assurez-vous que la fonctionnalité d'accessibilité
est requise pour les tests d'interface utilisateur.

00:32:53.780 --> 00:32:57.960
Ainsi, par exemple,
les critères d'acceptation, la plupart des entreprises

00:32:57.960 --> 00:33:00.070
et les équipes n'ont pas
de critères d'acceptation pour l'accessibilité.

00:33:00.070 --> 00:33:02.850
Si vous en avez, vous pouvez réellement
écrire des tests de régression

00:33:02.850 --> 00:33:05.030
pour ces
critères d'acceptation, ce qui est génial.

00:33:06.090 --> 00:33:07.670
Assurez-vous que
les équipes de développement sont conscientes

00:33:07.670 --> 00:33:10.350
que ces tests ne remplacent pas
les tests de lecteur d'écran ou du public régulier.

00:33:10.350 --> 00:33:11.150
C'est difficile à vendre.

00:33:11.150 --> 00:33:13.220
Je vais vous le dire tout de suite,
car lorsque vous empruntez ce chemin,

00:33:13.220 --> 00:33:16.280
beaucoup de gens disent, hé, je veux
automatiser toute l'accessibilité.

00:33:16.280 --> 00:33:20.140
Vous ne pouvez pas, mais cela aide à
atténuer la douleur de s'assurer

00:33:20.140 --> 00:33:23.420
que le contenu qui est accessible
reste accessible

00:33:23.420 --> 00:33:26.690
à moins que quelque chose n'arrive
en cours de route, comme des bugs des lecteurs d'écran

00:33:26.690 --> 00:33:27.210
ou des choses comme ça.

00:33:27.210 --> 00:33:28.800
Ils sont si rares et si éloignés les uns des autres.

00:33:28.800 --> 00:33:32.350
Cela garantit donc que le contenu est
accessible dès la sortie.

00:33:34.030 --> 00:33:36.330
Alors phase un, Linting.

00:33:36.330 --> 00:33:38.960
Phase deux,
bibliothèques de tests d'accessibilité.

00:33:38.960 --> 00:33:40.000
Phase trois, test de régression.

00:33:40.000 --> 00:33:43.850
Alors tu vas me demander maintenant, Mark,
sur cette première diapositive que tu avais ici,

00:33:43.850 --> 00:33:47.230
tu avais cette jolie chose qui disait
phase zéro. Tu vas dire,

00:33:47.230 --> 00:33:50.720
Et les extensions ?
Tu as raison.

00:33:50.720 --> 00:33:54.210
Des extensions existent et elles
ont un impact utile pour l'automatisation.

00:33:55.230 --> 00:33:56.760
Voici mon expérience
avec les extensions.

00:33:56.760 --> 00:33:59.490
Il n'existe aucun moyen réel,
duranr le cycle de vie en développement,

00:33:59.490 --> 00:34:01.750
de savoir si quelqu'un
utilise réellement une extension.

00:34:01.750 --> 00:34:05.440
Salut, j'ai été développeur
pendant longtemps.

00:34:05.440 --> 00:34:08.870
Si vous me donnez quelque chose pour lequel je vais
être soumis à un code d'honneur,

00:34:08.870 --> 00:34:12.100
dans un environnement agile et qui ne
connaît rien à l'accessibilité,

00:34:12.100 --> 00:34:12.640
devinez quoi ?

00:34:12.640 --> 00:34:14.030
Je ne vais pas le faire.

00:34:14.030 --> 00:34:16.010
Parce que le code d'honneur
n'est pas quelque chose pour

00:34:16.010 --> 00:34:18.960 
pour lequel je coche strictement une case
, est un critère d'acceptation,

00:34:18.960 --> 00:34:19.960
des choses comme ça.

00:34:20.850 --> 00:34:21.610
Devinez quoi ?

00:34:21.610 --> 00:34:25.040
La plupart des équipes qui utilisent uniquement des extensions
finissent par envoyer des éléments en production

00:34:25.040 --> 00:34:27.250
parce qu'il n'y a aucun moyen de le vérifier.

00:34:27.250 --> 00:34:28.930
Il n'y en a vraiment pas.

00:34:28.930 --> 00:34:31.810
Ainsi, les extensions peuvent toujours être
utilisées lorsque vous construisez

00:34:31.810 --> 00:34:32.830
et créer du nouveau contenu.

00:34:34.000 --> 00:34:40.170
Mais
l'automatisation des phases et de l'accessibilité, un, deux, trois,

00:34:40.170 --> 00:34:42.360
ceci permet de renforcer l'
utilisation de ces extensions.

00:34:42.360 --> 00:34:46.320
Donc si je crée mon contenu, je
le développe, je peux exécuter mon extension

00:34:46.320 --> 00:34:48.690
sur mon hôte local et dire,
Hé, il y a un problème.

00:34:48.690 --> 00:34:52.290
Et je peux jouer avec et essayer
de le réparer en direct, puis le mettre

00:34:52.290 --> 00:34:53.400
dans mon code.

00:34:53.400 --> 00:34:57.160
C'est l'utilisation pratique que je vois
encore et encore de la part des équipes.

00:34:57.160 --> 00:35:02.170
Nous avons tendance à considérer les extensions
comme une sorte de terrain de jeu

00:35:02.170 --> 00:35:05.750
pour pouvoir voir les
problèmes d'accessibilité puis les résoudre en direct.

00:35:05.750 --> 00:35:07.400
Cela aide à faire respecter cela.

00:35:07.400 --> 00:35:11.590
Le plus important, c'est qu'avec
les extensions, c'est très difficile à surveiller.

00:35:11.590 --> 00:35:14.360
Tant d'équipes que j'ai vues
disent : Hé, mets une capture d'écran

00:35:14.360 --> 00:35:17.060
de vos problèmes d'accessibilité
et vous n'avez aucun problème.

00:35:17.060 --> 00:35:19.510
Oui, j'ai déjà vu
ce système triché

00:35:19.510 --> 00:35:21.280
où quelqu'un prend
la même capture d'écran

00:35:21.280 --> 00:35:22.830
et dit, regarde, c'est réparé.

00:35:22.830 --> 00:35:25.940
Les extensions ont donc leur
place dans l'automatisation.

00:35:25.940 --> 00:35:26.230
Oui.

00:35:26.230 --> 00:35:29.290
100% parce que beaucoup
d'équipes les utilisent.

00:35:29.290 --> 00:35:31.940
Mais en ce qui concerne l'application et
la mise en place au jour le jour,

00:35:31.940 --> 00:35:35.320
vous devez utiliser les
parties de phasage de la phase un, de la phase deux,

00:35:35.320 --> 00:35:38.980
et si vous arrivez à la phase trois, phase
trois, pour obtenir correctement des extensions

00:35:38.980 --> 00:35:41.510
pour être utilisés comme
ils devraient l'être.

00:35:41.510 --> 00:35:45.020
Pour aller au-delà de ce que
font les tests d'automatisation.

00:35:45.020 --> 00:35:47.332
C'est juste tellement difficile d'
appliquer des extensions

00:35:47.333 --> 00:35:48.950
pour dire, Hé, je vais commencer

00:35:48.950 --> 00:35:50.300
à utiliser les extensions et c'est parti.

00:35:52.651 --> 00:35:56.351
Donc, pour compléter
un peu cela.

00:35:58.040 --> 00:36:02.570
Je dis ce terme, Merrill Evans
dit un terme similaire à celui-ci aussi,

00:36:02.570 --> 00:36:03.850
de petites victoires pour de gros gains.

00:36:03.850 --> 00:36:08.220
La plupart des réactions que j'en tire,
c'est que c'est beaucoup

00:36:08.220 --> 00:36:09.790
de phases juste pour l'automatisation.

00:36:09.790 --> 00:36:11.510
Tu as raison, c'est vrai.

00:36:11.510 --> 00:36:14.300
Mais je vous le dis tout de
suite, la façon dont vous obtenez

00:36:14.300 --> 00:36:18.820
dans le cycle de vie du développement,
vous devez vous adapter à ce qui est fait.

00:36:18.820 --> 00:36:22.270
L'accessibilité a longtemps
été considérée comme quelque chose

00:36:22.270 --> 00:36:24.840
qui ralentit tout le processus.

00:36:24.840 --> 00:36:26.200
Ça ralentit tout.

00:36:26.200 --> 00:36:29.100
L'automatisation est donc arrivée pour dire,
oui, accélérons cela.

00:36:29.100 --> 00:36:32.970
Mais le problème est que
l'automatisation est presque allée trop loin.

00:36:32.970 --> 00:36:36.310
Ce qui s'est passé ensuite, c'est
que l'automatisation est allée trop loin,

00:36:36.310 --> 00:36:40.680
nous avons surpeuplé,
nous avons surchargé l'environnement de développement,

00:36:40.680 --> 00:36:42.700
toutes ces différentes choses
que nous pouvons utiliser pour l'automatisation.

00:36:42.700 --> 00:36:47.420
Et maintenant, nos développeurs sont revenus et ont dit,
ah, c'est encore trop.

00:36:47.420 --> 00:36:49.690
Donc c'est un peu comme ce cycle.

00:36:49.690 --> 00:36:55.260
Donc, le mettre en place progressivement nous permet
de pouvoir établir une culture

00:36:55.260 --> 00:36:58.120
d'accessibilité pour le futur.

00:36:58.120 --> 00:37:00.780
Beaucoup de gens pensent que lorsque
je dis cela, ce n'est pas vrai.

00:37:00.780 --> 00:37:02.000
C'est vraiment le cas.

00:37:02.000 --> 00:37:05.790
Aussi petite que soit l'automatisation, il s'agit d'une petite
sous-tâche de choses que ces choses font

00:37:05.790 --> 00:37:08.310
dans un petit nombre de
problèmes qu'ils détectent.

00:37:08.310 --> 00:37:14.790
Il y a toujours
un courant sous-jacent d'accessibilité.

00:37:14.790 --> 00:37:16.947
Une vague peut arriver
très rapidement

00:37:16.948 --> 00:37:18.780
et dire, hé, répare tout ça.

00:37:18.780 --> 00:37:21.060
Les vagues peuvent devenir grosses,
les vagues peuvent devenir petites,

00:37:21.060 --> 00:37:22.600
mais les courants sous-jacents
restent toujours là.

00:37:22.600 --> 00:37:24.940
Vous voulez que l'accessibilité
reste un courant sous-jacent.

00:37:26.150 --> 00:37:28.320
Donc c'est constamment là et
cela rappelle constamment à tout le monde

00:37:28.320 --> 00:37:30.630
que l'accessibilité est importante
et [Inaudible 37:32].

00:37:30.630 --> 00:37:34.030
Donc si nous continuons à dire d'
automatiser, nous finirons

00:37:34.030 --> 00:37:35.450
avec le même cycle que celui dans lequel nous avons été.

00:37:35.450 --> 00:37:37.690
Nous devons donc commencer
à l'introduire progressivement pour que cela reste.

00:37:37.690 --> 00:37:41.930
Et un dernier mot
avant d'en finir.

00:37:41.930 --> 00:37:45.660
L'accessibilité automatisée, à vrai
dire, a mauvaise réputation

00:37:45.660 --> 00:37:47.540
dans notre domaine, et pour cause.

00:37:48.560 --> 00:37:50.000
Des superpositions existent.

00:37:51.280 --> 00:37:53.950
Il y a encore des développeurs
qui pensent que cela résout

00:37:53.950 --> 00:37:55.030
tous les problèmes d'accessibilité.

00:37:55.030 --> 00:37:56.820
Je peux tout automatiser.

00:37:58.070 --> 00:38:00.870
Il y a encore des gens qui
pourraient mettre à jour ceci et dire :

00:38:00.870 --> 00:38:02.800
ils pensent que l'IA va
tout arranger avec ça.

00:38:02.800 --> 00:38:04.910
Parce que c'est automatisé.

00:38:04.910 --> 00:38:05.910
Voilà l'affaire.

00:38:05.910 --> 00:38:08.350
En fin de compte,
c'est un portail et une passerelle

00:38:08.350 --> 00:38:10.960
dans un domaine qui est
vraiment difficile à percer.

00:38:10.960 --> 00:38:13.890
Je le dis encore et encore.

00:38:13.890 --> 00:38:19.420
Les coquilles des équipes de développement
sont extrêmement difficiles à casser.

00:38:19.420 --> 00:38:21.820
Au quotidien, dans le
domaine de l'accessibilité, nous nous disons :

00:38:21.820 --> 00:38:23.920
Pourquoi n'ont-ils pas rendu
cela accessible.

00:38:23.920 --> 00:38:26.290
À vrai dire, je suis
aussi frustré, ne vous inquiètez pas.

00:38:26.290 --> 00:38:30.300
Mais avec tout ce que
les équipes agiles doivent faire, les délais sont serrés,

00:38:30.300 --> 00:38:33.480
sortir des choses dehors,
ça devient vraiment fastidieux pour eux.

00:38:33.480 --> 00:38:38.730
Et donc casser cette coquille est très
difficile parce qu'ils ne veulent pas

00:38:38.730 --> 00:38:41.320
y ajouter d'autres tâches ou d'
autres choses et je comprends.

00:38:41.320 --> 00:38:42.500
J'ai passé par là, j'ai fait ça.

00:38:42.500 --> 00:38:46.320
Il faut donc procéder progressivement
pour arriver là où cela doit aller.

00:38:46.320 --> 00:38:48.960
Cela peut vraiment aider une
équipe de développement à apprendre rapidement

00:38:48.960 --> 00:38:50.410
sans ralentir.

00:38:50.410 --> 00:38:55.010
Et cela peut renforcer la culture de
votre équipe de développement au fur et à mesure.

00:38:55.010 --> 00:38:59.210
Encore une fois, en revenant en arrière, l'
enquête webAIM nous dit une chose :

00:38:59.210 --> 00:39:00.912
ce que nous avons fait du
point de vue de l'automatisation

00:39:00.913 --> 00:39:01.600
ne fonctionne toujours pas.

00:39:01.600 --> 00:39:04.890
Nous nous jetons simplement contre le mur
et disons, hé, allez faire de l'automatisation.

00:39:04.890 --> 00:39:06.890
Ça ne marche pas.

00:39:06.890 --> 00:39:08.398
Mettre en place progressivement, avoir un plan,

00:39:08.399 --> 00:39:10.530
comprendre
systématiquement ce que nous avons à

00:39:10.530 --> 00:39:15.720
faire pour que ça dure aidera
toutes les équipes de développement

00:39:15.720 --> 00:39:18.040
à choisir l'accessibilité
et l'encourager.

00:39:18.040 --> 00:39:23.030
Donc mon dernier mot est de créer
une meilleure automatisation de l'accessibilité.

00:39:23.030 --> 00:39:25.490
Tuons la réputation
selon laquelle l'automatisation va

00:39:25.491 --> 00:39:26.600
tout envahir.

00:39:26.600 --> 00:39:28.220
Tout le monde pense que ça
va diriger le monde.

00:39:28.220 --> 00:39:29.260
Non.

00:39:29.260 --> 00:39:32.790
C'est une passerelle vers
les équipes de développement qui leur permet vraiment

00:39:32.790 --> 00:39:35.320
de bien apprendre
l'accessibilité à grande vitesse

00:39:35.320 --> 00:39:39.170
et de bâtir cette culture autour
de l'accessibilité à l'avenir.

00:39:39.170 --> 00:39:41.480
Alors construisons
une meilleure automatisation quotidienne

00:39:41.480 --> 00:39:45.520
et intégrons l'accessibilité
dans le cycle de vie du développement.

00:39:46.700 --> 00:39:47.210
Et c'est tout.

00:39:47.210 --> 00:39:49.020
Et c'est tout pour moi.

00:39:49.020 --> 00:39:50.020
Youpi.

00:39:51.060 --> 00:39:52.060
Je vais probablement faire plus de café maintenant.

00:39:53.010 --> 00:39:55.080
<v Joost> Eh bien,
vous avez mérité votre café.

00:39:55.080 --> 00:39:55.760
C'est sûr.

00:39:55.760 --> 00:39:56.490
Merci, Mark.

00:39:56.490 --> 00:39:57.830
C'était excellent.

00:39:57.830 --> 00:39:59.460
Merci beaucoup.

00:39:59.460 --> 00:40:01.040
J'ai pris des notes.

00:40:01.040 --> 00:40:03.010
L'une des premières
choses que j'ai réalisé

00:40:03.010 --> 00:40:05.963
alors que je regardais
votre présentation...

00:40:05.964 --> 00:40:07.620
Nous avons toujours eu beaucoup

00:40:07.620 --> 00:40:10.140
de tests automatisés chez
Yoast, ce que j'ai trouvé.

00:40:11.160 --> 00:40:14.520
Et je ne pense pas que nous ayons jamais
vraiment atteint le point

00:40:14.520 --> 00:40:17.270
où nous avons effectué de nombreux
tests d'accessibilité automatisés.

00:40:18.340 --> 00:40:22.120
Mais beaucoup d'entre eux semblent
en fait très faciles

00:40:22.120 --> 00:40:24.080
à copier-coller d'un
projet à un autre.

00:40:24.980 --> 00:40:25.330
<v Mark> Oui.

00:40:25.330 --> 00:40:27.200
<v Joost> Y a-t-il un
endroit où les gens partagent

00:40:27.200 --> 00:40:32.180
ces choses en ligne en open source
d'une manière que nous pouvons simplement faire cela ?

00:40:32.180 --> 00:40:33.120
Où fais-tu ça ?

00:40:34.610 --> 00:40:37.820
<v Mark> Je peux donc partager cela avec
tous ceux qui sont sur les chaînes Slack

00:40:37.820 --> 00:40:39.290
et je le partagerai sur
Twitter et LinkedIn.

00:40:39.290 --> 00:40:45.320
Donc, en fait, je fais un
deck entier.

00:40:45.320 --> 00:40:47.830
C'est une des choses que
je suis en train de faire.

00:40:47.830 --> 00:40:52.930
Je suis en train de créer toute une
suite d'exemples accessibles

00:40:52.930 --> 00:40:53.880
qui existent ça et là.

00:40:53.880 --> 00:40:55.220
Je pourrai partager ça avec
tout le monde après ça.

00:40:55.220 --> 00:40:56.620
Il n'y en a que quelques-uns
pour le moment.

00:40:56.620 --> 00:40:57.900
Voici mon React
sur mon téléphone Cypher.

00:40:57.900 --> 00:41:01.340
Je le fais quand j'ai du temps, mais que
se passe-t-il quand on a deux enfants ?

00:41:01.340 --> 00:41:04.760
Mais j'ai des exemples
qui fonctionnent pour le montrer.

00:41:05.880 --> 00:41:08.160
Il y a aussi d'autres exemples qui existent.

00:41:08.160 --> 00:41:13.580
Je pense qu'en termes d'open source, Deque
Systems en a pour axe-core.

00:41:13.580 --> 00:41:14.960
Il n'y en a que quelques-uns.

00:41:14.960 --> 00:41:18.230
Mais mon objectif est de créer
des exemples de bibliothèques pour présenter

00:41:18.230 --> 00:41:20.290
à quel point il est facile de copier
et coller ces choses.

00:41:20.290 --> 00:41:23.350
Parce que vraiment, ce dont vous parlez
, c'est le cas.

00:41:23.350 --> 00:41:27.360
Vous pouvez littéralement copier et coller
une fois que vous avez ces cas de test

00:41:27.360 --> 00:41:27.930
dans tous les domaines.

00:41:27.930 --> 00:41:29.940
Et tout le monde a tendance à
me sauter dessus pour me dire :

00:41:29.940 --> 00:41:31.450
copier-coller, vraiment Mark,
de quoi parles-tu ?

00:41:31.450 --> 00:41:32.280
Vous ne faites pas de copier-coller.

00:41:32.280 --> 00:41:33.370
Je dis : tu peux.

00:41:33.370 --> 00:41:36.230
Vous avez correctement configuré vos scénarios de test
et tout est configuré

00:41:36.230 --> 00:41:38.480
d'une manière qui sera
lue et accessible.

00:41:38.480 --> 00:41:39.440
C'est relativement simple.

00:41:39.440 --> 00:41:43.510
Donc oui, je peux également
publier certaines de ces ressources que je connais après cela.

00:41:44.380 --> 00:41:47.290
<v Joost> Oui, eh bien,
ce serait génial parce que je sais

00:41:47.290 --> 00:41:50.880
qu'il n'y a pas encore beaucoup de
cela dans le coeur de WordPress non plus.

00:41:50.880 --> 00:41:53.243
Et je pense que cela
bénéficierait énormément

00:41:53.244 --> 00:41:57.000
de faire un peu plus
de ça parce que je suis d'accord avec toi.

00:41:57.000 --> 00:42:03.260
Ce que j'ai le plus entendu contre
les travaux d'accessibilité comme celui-ci, c'est :

00:42:03.260 --> 00:42:04.710
oui ça ralentit tout.

00:42:04.710 --> 00:42:08.140
Et c'est comme si j'en avais marre
d'entendre cet argument...

00:42:09.680 --> 00:42:12.520
<v Mark> Partout et partout où je
vais, c'est le même argument encore

00:42:12.520 --> 00:42:13.070
et encore.

00:42:13.070 --> 00:42:14.546
Et encore une fois,
c'est le premier contrecoup

00:42:14.547 --> 00:42:18.250
contre laquelle nous devons lutter.
Cela ne fera que nous ralentir.

00:42:18.250 --> 00:42:21.080
Et la vérité est
que mon expérience

00:42:21.080 --> 00:42:25.750
avec la mise en phase a fonctionné
relativement bien pour amener les équipes

00:42:25.750 --> 00:42:28.260
à dire, hé,
ce ne sont que des compléments très simples

00:42:28.260 --> 00:42:29.790
pour ce que nous faisons en ce moment.

00:42:29.790 --> 00:42:31.390
Quoi que vous utilisiez,
nous allons les construire

00:42:31.390 --> 00:42:32.280
avec ce que vous avez.

00:42:33.300 --> 00:42:34.210
<v Joost> Parfait.

00:42:34.210 --> 00:42:36.780
OK, nous avons les premières
questions qui arrivent.

00:42:36.780 --> 00:42:40.040
Ben Ogilfee demande :
Connaissez-vous des considérations

00:42:40.040 --> 00:42:45.010
ou les limites de certaines de
ces approches telles qu'elles s'appliquent

00:42:45.010 --> 00:42:46.420
aux versions WordPress ?

00:42:46.420 --> 00:42:47.600
<v Mark> Oui.

00:42:47.600 --> 00:42:51.460
Certaines des choses dont nous avons parlé
en ce qui concerne les linters,

00:42:51.460 --> 00:42:55.110
l'accessibilité se construit d'elle-même,
comme les intégrations réelles

00:42:55.110 --> 00:42:57.840
n'existent pas encore
dans les versions WordPress.

00:42:57.840 --> 00:43:01.630
Donc certains d'entre eux le font, certains des
linters que j'ai vérifiés existent

00:43:01.630 --> 00:43:02.960
pour ça, mais certains ne le font pas.

00:43:02.960 --> 00:43:05.100
C'est juste un produit de la façon dont
certaines des bibliothèques de test

00:43:05.100 --> 00:43:06.360
et les choses fonctionnent.

00:43:06.360 --> 00:43:10.300
Ce seraient donc les seules
limitations qui existent actuellement.

00:43:10.300 --> 00:43:14.690
La question est simplement de savoir s'ils sont disponibles pour les
builds eux-mêmes qui sont disponibles ?

00:43:14.690 --> 00:43:17.610
à vrai dire, c'est difficile
parce que parfois, comme

00:43:17.610 --> 00:43:22.630
quand vous exécutez des trucs avec
ça, vous rencontrez des problèmes

00:43:22.630 --> 00:43:25.910
là où vous ne les avez pas.

00:43:25.910 --> 00:43:28.900
Par exemple,
je sais que j'en regardais un.

00:43:28.900 --> 00:43:31.200
Je pense que c'était un Vue.

00:43:31.200 --> 00:43:33.630
Le site WordPress
a été construit avec Vue.

00:43:33.630 --> 00:43:35.880
Il n'y avait pas
de règles d'accessibilité ou de linting,

00:43:35.880 --> 00:43:38.830
mais il y avait un linter général qui
contenait des règles d'accessibilité.

00:43:38.830 --> 00:43:41.190
Dans le pire des cas,
prenez le général.

00:43:41.190 --> 00:43:44.660
Au moins,
des contrôles d'accessibilité sont effectués au fur et � mesure que le contenu est créé.

00:43:44.660 --> 00:43:47.260
Mais en réalité, la limitation est la suivante :
sont-ils disponibles ou non

00:43:47.260 --> 00:43:48.810
du point de vue du linting ou
de la bibliothèque ?

00:43:49.500 --> 00:43:50.540
<v Joost> Oui, super.

00:43:53.170 --> 00:43:56.640
Ben Eisenberg demande :
qu'en est-il de la mise à jour des anciens sites ?

00:43:56.640 --> 00:43:59.241
Quels sont les gains faciles
sur lesquels se concentrer pour les sites plus anciens

00:43:59.242 --> 00:44:00.790
qui doivent être entretenus ?

00:44:00.790 --> 00:44:01.730
<v Mark> Oh, d'accord.

00:44:01.730 --> 00:44:04.450
Donc il y a deux choses
avec des sites plus anciens.

00:44:04.450 --> 00:44:09.810
Donc ce que je suggère toujours
avec un site plus ancien,

00:44:09.810 --> 00:44:12.473
il y a deux choses
que vous pouvez faire en fonction

00:44:12.474 --> 00:44:14.670
de la façon dont vous le mettez réellement à jour,

00:44:15.720 --> 00:44:18.590
si vous souhaitez revenir en arrière
et mettre à jour l'ancien code, ce n'est pas un problème.

00:44:18.590 --> 00:44:21.750
Mais il y a certaines équipes que
je connais qui viennent

00:44:21.750 --> 00:44:24.130
de passer par là, et je sais que
tout le monde va frissonner

00:44:24.130 --> 00:44:27.280
quand je vais dire ça, et sont
tombés sur des problèmes simples

00:44:27.280 --> 00:44:30.020
parce qu'ils n'ont pas réellement
accès au code.

00:44:30.020 --> 00:44:32.183
Ils ont juste
ajouté du JavaScript

00:44:32.184 --> 00:44:33.560
dans des problèmes spécifiques résolus.

00:44:33.560 --> 00:44:35.310
Ils ne vont pas jusqu'à dire,
hé, donnez-moi quelque chose d'ordre général.

00:44:35.310 --> 00:44:38.120
Ils résolvent
des problèmes spécifiques avec JavaScript.

00:44:38.120 --> 00:44:39.220
C'est une façon.

00:44:39.220 --> 00:44:44.170
L'autre chose que je suggère pour
les sites plus anciens est de savoir si vous avez un moyen

00:44:44.170 --> 00:44:46.830
pour mettre en place un
test d'intégration pour vous-même, par exemple,

00:44:46.830 --> 00:44:48.690
Hé, mettez en place une bibliothèque pour
parcourir ces choses

00:44:48.690 --> 00:44:52.550
et vérifiez les problèmes, au
minimum, corrigez les problèmes automatisés.

00:44:52.550 --> 00:44:56.880
La plupart des anciens sites eux-mêmes
sont en réalité réalisés en HTML sémantique.

00:44:56.880 --> 00:44:59.840
Donc la plupart des problèmes
que vous rencontrez surviennent

00:44:59.840 --> 00:45:06.750
parce qu'il manque incorrectement
des attributs d'aria ou des choses comme ça.

00:45:06.750 --> 00:45:09.950
Donc sémantiquement c'est génial, c'est
juste qu'il te manque de petites choses.

00:45:09.950 --> 00:45:13.270
Si vous pouvez exécuter une suite de tests
sur cela ou même sur une extension,

00:45:13.270 --> 00:45:15.920
cela rend les choses plus faciles à faire mais
ces deux choses sont normalement

00:45:15.920 --> 00:45:18.160
ce que je vois pour les sites plus anciens.

00:45:18.160 --> 00:45:21.220
J'essaie juste de réparer ce que vous pouvez
réparer, que ce soit avec JavaScript

00:45:21.220 --> 00:45:23.810
ou autre et éliminez les
problèmes simples.

00:45:25.420 --> 00:45:26.940
<v Joost> Super.

00:45:26.940 --> 00:45:30.670
Nous avons une autre question ou en fait
je pense que c'est trois questions

00:45:30.670 --> 00:45:32.250
donc je vais
les demander une par une.

00:45:32.250 --> 00:45:36.240
De Scott Thorneburn : Combien
de temps cela prend-il en moyenne

00:45:36.240 --> 00:45:39.140
pour provoquer des changements lorsque vous
apportez cela avec une équipe de développement.

00:45:40.430 --> 00:45:41.110
<v Mark> Whoo.

00:45:41.110 --> 00:45:46.720
OK, donc phase un et phase
deux, spécifiquement pour le linting

00:45:46.720 --> 00:45:49.550
si vous savez qu'ils
utilisent un linter spécifique,

00:45:49.550 --> 00:45:51.500
et vous pouvez simplement dire d'activer
les règles d'accessibilité,

00:45:51.500 --> 00:45:53.720
que la première phase peut prendre une semaine.

00:45:53.720 --> 00:45:55.460
Et dites simplement oui, cela
fait partie du processus maintenant.

00:45:55.460 --> 00:45:58.540
Nous utilisons
des règles d'accessibilité et vous devez les corriger.

00:45:58.540 --> 00:46:04.790
Le délai le plus rapide que j'ai vu pour la
première et la deuxième phase est d'un mois

00:46:04.790 --> 00:46:08.790
donc si vous faites
des sprints de deux semaines, deux, genre deux sprints.

00:46:10.210 --> 00:46:12.370
Donc normalement, c'est
probablement environ cela.

00:46:12.370 --> 00:46:14.430
La première phase consiste normalement
en un sprint ou deux.

00:46:15.440 --> 00:46:20.900
Phase trois, normalement parce que ce sont
les gens du contrôle qualité et que les gens du contrôle qualité se soucient vraiment

00:46:20.900 --> 00:46:22.990
des tests d'interface utilisateur qu'ils rédigent.

00:46:22.990 --> 00:46:25.990
Cela prend normalement probablement environ
deux ou trois mois.

00:46:25.990 --> 00:46:27.260
Et puis
des tests de régression, je vais être honnête.

00:46:27.260 --> 00:46:31.230
Le test de régression peuvent être
très difficile à obtenir.

00:46:31.230 --> 00:46:33.270
J'en parle ici
parce que c'est vraiment génial

00:46:33.270 --> 00:46:36.620
parce que je crois que
cela a beaucoup de valeur.

00:46:36.620 --> 00:46:39.980
Je n'ai vu que deux
équipes ou organisations de développement avec lesquelles j'ai travaillées

00:46:39.980 --> 00:46:42.170
qui ont réellement fait ça.

00:46:42.170 --> 00:46:45.250
Cela prend beaucoup de temps pour y arriver
parce qu'une fois que vous avez atteint la première phase,

00:46:45.250 --> 00:46:47.720
phase deux, souvent
c'est comme, oh mon Dieu,

00:46:47.720 --> 00:46:49.170
d'où viennent tous ces
problèmes ?

00:46:49.170 --> 00:46:51.360
Et puis vous devez commencer à
trouver un processus pour les réparer

00:46:51.360 --> 00:46:52.750
et les assimiler.

00:46:52.750 --> 00:46:55.050
C'est donc normalement le délai
avec une équipe de développement.

00:46:56.270 --> 00:46:57.170
<v Joost> Super.

00:46:57.170 --> 00:47:02.930
Et à combien estimez-vous le
coût et le ralentissement initial

00:47:02.930 --> 00:47:04.620
sur des projets pour mettre
ces choses en place ?

00:47:04.620 --> 00:47:05.610
<v Mark> Bien sûr.

00:47:05.610 --> 00:47:07.450
Donc Linting, rien.

00:47:07.450 --> 00:47:09.110
Il n'y a aucun argument
contre Linting.

00:47:09.110 --> 00:47:10.660
Si vous avez un linter
en cours d'exécution en ce moment,

00:47:10.660 --> 00:47:13.910
exécutez les règles d'accessibilité, elles sont
activées, vous n'avez rien ralenti.

00:47:13.910 --> 00:47:16.920
Il aurait fallu 30
secondes de plus à un développeur,

00:47:16.920 --> 00:47:19.610
oh, j'ai besoin d'un attribut alt
là-dessus, compris.

00:47:21.270 --> 00:47:24.850
Pour quelque chose comme les
bibliothèques de tests et des choses comme ça,

00:47:24.850 --> 00:47:27.510
vous pourriez regarder si je
devais ajouter cela dans un sprint,

00:47:27.510 --> 00:47:29.860
cela pourrait ralentir un
peu les choses pour vos responsables du contrôle qualité.

00:47:29.860 --> 00:47:32.740
Cependant,
si vous avez une équipe CQ ou quelqu'un

00:47:32.740 --> 00:47:35.360
qui écrit
lui-même le scénario de test, comme nous l'avons montré,

00:47:35.360 --> 00:47:37.430
la configuration initiale est
vraiment la partie la plus difficile.

00:47:37.430 --> 00:47:40.470
Après cela, il s'agit simplement de
copier-coller et de répéter.

00:47:40.470 --> 00:47:44.200
Donc le ralentissement est probablement un sprint
ou deux pour le mettre en place et le faire fonctionner,

00:47:44.200 --> 00:47:46.620
mais en réalité, le ralentissement ne coûte
pas très cher.

00:47:46.620 --> 00:47:47.810
Tests de régression, bien sûr.

00:47:47.810 --> 00:47:50.010
Cela prend un peu de temps à
comprendre, Hé, comment je vais

00:47:50.010 --> 00:47:52.060
pour écrire
des tests de régression fonctionnels pour quelque chose.

00:47:52.060 --> 00:47:54.361
Mais les deux premiers,
le premier en particulier,

00:47:54.362 --> 00:47:56.020
il n'y a aucun problème de ralentissement.

00:47:56.020 --> 00:47:58.530
Deuxième, il pourrait y avoir
un certain ralentissement, mais tout est là.

00:47:58.530 --> 00:48:00.770
cela dépend
aussi de la structure du projet.

00:48:00.770 --> 00:48:01.900
<v Joost> Clair.

00:48:01.900 --> 00:48:06.240
Et comment obtenez-vous un accord avec le
Dev sur les outils automatisés à utiliser ?

00:48:06.240 --> 00:48:10.610
Utilisez-vous toujours simplement
ce qu'ils utilisent déjà ?

00:48:10.610 --> 00:48:13.150
<v Mark> Je me base toujours
sur ce qu'ils font.

00:48:13.150 --> 00:48:16.700
La première question que je pose est : Hé,
qu'est-ce que tu utilises pour une équipe ?

00:48:16.700 --> 00:48:18.793
Qu'utilisez-vous pour
les tests automatisés ?

00:48:18.794 --> 00:48:23.520
Et puis nous comblons les lacunes
en matière d'accessibilité.

00:48:23.520 --> 00:48:26.570
Parce que s'ils n'ont pas
décidé, je dis toujours ceci,

00:48:26.570 --> 00:48:30.030
s'ils n'ont pas décidé d'
une stratégie de test, poussez-les

00:48:30.030 --> 00:48:32.690
pour le découvrir eux-mêmes
parce que si vous dites, eh bien,

00:48:32.690 --> 00:48:36.170
nous devrions utiliser ça,
ça finit toujours en désastre.

00:48:36.170 --> 00:48:38.200
Parce qu'alors ils commencent à se
dire, oh non, non, non,

00:48:38.200 --> 00:48:38.820
nous allons utiliser ça.

00:48:38.820 --> 00:48:39.530
C'est comme, OK, super.

00:48:39.530 --> 00:48:43.010
Donc si une équipe sait déjà,
elle va avec ce qu'elle a, elle va

00:48:43.010 --> 00:48:45.650
avec ce qu'ils utilisent et disent,
Hé, nous allons inclure

00:48:45.650 --> 00:48:48.130
l'accessibilité avec ça.
S'ils ne le font pas.

00:48:48.130 --> 00:48:51.190
Alors vous pouvez dire Super,
vous avez compris en premier.

00:48:51.190 --> 00:48:52.270
C'est juste mon expérience.

00:48:52.270 --> 00:48:53.940
Vous l'avez compris en premier,
je reviendrai et étudierai

00:48:53.940 --> 00:48:56.020
ce que nous devrions faire du
côté de l'accessibilité.

00:48:56.020 --> 00:48:59.140
Si nous le forçons à partir de l'accessibilité,
alors cela devient complètement désordonné.

00:48:59.140 --> 00:49:02.250
<v Joost> Oui, j'apprécie pleinement cela.

00:49:02.250 --> 00:49:06.840
Andrea Fershia demande, en 2017,
aux serveurs numériques du gouvernement britannique

00:49:06.840 --> 00:49:11.280
ils ont réalisé un audit des
vérificateurs automatisés d'accessibilité les plus populaires

00:49:11.280 --> 00:49:14.750
et ont découvert que même le meilleur
n'était capable de trouver que 40 %

00:49:14.750 --> 00:49:15.570
des problèmes.

00:49:15.570 --> 00:49:15.910
<v Mark> Oui.

00:49:16.996 --> 00:49:19.850
<v Joost> Savez-vous par hasard si
de nouveaux audits ont été effectués depuis,

00:49:19.850 --> 00:49:23.260
la précision de ces
outils s'est-elle généralement améliorée ?

00:49:23.978 --> 00:49:26.410
<v Mark> Bien sûr, donc je vais résumer
très rapidement.

00:49:26.410 --> 00:49:31.640
Andrea, c'est le consensus général ;
30 à 40% de problèmes d'accessibilité.

00:49:31.640 --> 00:49:34.970
La seule chose que je
peux dire de différent, c'est,

00:49:34.970 --> 00:49:36.950
Deque Systems a réalisé une étude à ce sujet.

00:49:36.950 --> 00:49:40.080
Quelqu'un d'autre a fait une étude
là-dessus aussi, j'ai oublié de qui il s'agissait.

00:49:40.080 --> 00:49:43.410
Deque Systems a effectué tous les
audits d'accessibilité qu'ils avaient effectués

00:49:43.410 --> 00:49:45.140
d'un point de vue manuel,
d'un point de vue automatisé.

00:49:45.140 --> 00:49:48.230
Ils les ont rassemblés et
ont dit, en volume,

00:49:48.230 --> 00:49:50.450
Dans quelle mesure les problèmes
ont-ils été détectés par l'automatisation ?

00:49:50.450 --> 00:49:54.130
Ils ont identifié, je pense
, 56 % de tous les problèmes d'accessibilité.

00:49:54.130 --> 00:49:54.800
c'est manuel.

00:49:54.800 --> 00:49:57.040
Et les automatisés ont été
rattrapés par l'automatisation.

00:49:57.040 --> 00:50:00.000
C'est en fonction du volume, pas en fonction
des critères de réussite ou de quelque chose comme ça.

00:50:00.000 --> 00:50:02.960
Encore une fois, ça dépend comment on le voit.

00:50:02.960 --> 00:50:06.410
Donc si vous dites 30 % de
critères de réussite, 100 %, c'est ce que je dis,

00:50:06.410 --> 00:50:07.760
100%, désolé.

00:50:07.760 --> 00:50:09.650
C'est ce que je dis normalement
aussi, car c'est le tiers inférieur

00:50:09.650 --> 00:50:11.000
de problèmes d'accessibilité.

00:50:11.000 --> 00:50:13.130
Si vous regardez en volume,
il existe des études

00:50:13.130 --> 00:50:15.740
qui disent que c'est plus proche de 50
à cause de tous les problèmes

00:50:15.740 --> 00:50:18.220
qui existent sur le
Web, mais je ne sais pas

00:50:18.220 --> 00:50:20.180
de toutes les nouvelles qui
ont été faites, non.

00:50:21.970 --> 00:50:26.870
<v Joost> Nous arrivons ainsi à
la fin de notre liste de questions

00:50:26.870 --> 00:50:29.090
et nous allons vous libérer.

00:50:29.090 --> 00:50:32.340
Merci encore Mark pour
votre excellente présentation

00:50:32.340 --> 00:50:34.550
et merci à tous d'être venus.

00:50:35.600 --> 00:50:38.140
Vous pouvez continuer la
conversation sur le chat

00:50:38.140 --> 00:50:45.390
ou sur les réseaux sociaux en utilisant les
hashtags wpa11yday et wpad2023.

00:50:45.390 --> 00:50:47.290
Nous
apprécions aussi beaucoup si vous vous rendez

00:50:47.290 --> 00:50:51.400
sur le
site Web de la journée d'accessibilité de WP et aux commentaires

00:50:51.400 --> 00:50:54.130
pour fournir
des commentaires anonymes sur nos conférenciers et

00:50:54.130 --> 00:50:59.560
sur nos présentations et si vous
osez, vous pouvez participer pour gagner un t-shirt.

00:50:59.560 --> 00:51:02.550
Restez à l'écoute pour savoir comment
coder pour l'accès par mot clé

00:51:02.550 --> 00:51:06.440
dans WordPress à venir
avec Priti Rohra en tête

00:51:06.440 --> 00:51:09.010
de l'heure ou 12:00 UTC.

00:51:09.010 --> 00:51:12.460
Et pendant que vous attendez, n'oubliez pas
de visiter les pages de nos commanditaires

00:51:12.460 --> 00:51:17.020
pour récupérer des objets virtuels et participer
pour gagner de superbes prix.

00:51:17.020 --> 00:51:20.120
C'est moi
aussi qui signe mon rôle de MC pour aujourd'hui.

00:51:20.120 --> 00:51:23.550
J'espère que vous apprécierez le reste de
la journée d'accessibilité de WordPress

00:51:23.550 --> 00:51:25.380
et on se retrouve
ici après votre pause.

00:51:28.620 --> 00:51:33.260
<v Intervenant 1> Merci aux
commanditaires de la Journée de l'accessibilité WordPress 2023.

00:51:33.260 --> 00:51:36.140
Commanditaire Platine : Equalize Digital.

00:51:36.140 --> 00:51:38.890
L'extension de vérification d'accessibilité
d'Equalize Digital

00:51:38.890 --> 00:51:41.640
est un
outil d'analyse d'accessibilité automatisé

00:51:41.640 --> 00:51:44.820
qui aide les sites WordPress
à devenir et à rester accessibles.

00:51:46.070 --> 00:51:51.010
Commanditaire Platine Gravity Forms :
Gravity Forms est le constructeur professionnel

00:51:51.010 --> 00:51:54.170
de formulaires dont vous
avez besoin pour créer de beaux,

00:51:54.170 --> 00:51:57.270
puissants et accessibles formulaires.

00:51:57.270 --> 00:52:03.170
Les commanditaires Gold sont 20i, Deque,
Empire Caption Solutions,

00:52:03.170 --> 00:52:05.360
Pressable et WP Engine.

00:52:06.930 --> 00:52:13.800
Commanditaires Argent, Code Geek, Drake
Cooper, GoDaddy, LoneRock Point,

00:52:13.800 --> 00:52:19.030
NerdPress, Overnight Website par
KineticIRIS, Raiola Networks,

00:52:20.290 --> 00:52:23.300
A11Y Collective et Blogsmith.

00:52:25.170 --> 00:52:30.580
Commanditaires Bronze, AccessiCart,
Web GreenGeeks Web Hosting,

00:52:30.580 --> 00:52:38.580
Hall Analysis SEO Consulting,
HDC, ITX, Ivy Cat, Metabox,

00:52:42.330 --> 00:52:47.243
Pixel Chefs, Simply Schedule
Appointments, SiteGround,

00:52:47.244 --> 00:52:52.470
Termageddon, Underrepresented
in Tech,  Weglot et Yoast.
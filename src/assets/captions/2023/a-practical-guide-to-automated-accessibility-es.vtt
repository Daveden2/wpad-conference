WEBVTT

00:00:00.984 --> 00:00:05.690
Día de la Accesibilidad WordPress
2023, una guía práctica

00:00:05.690 --> 00:00:09.930
para la accesibilidad automatizada
con Mark Steadman, Director de

00:00:09.930 --> 00:00:13.220
Accesibilidad móvil en
Fidelity Investments.

00:00:13.220 --> 00:00:17.210
Esta presentación se
grabó el 28 de septiembre de 2023.

00:00:17.210 --> 00:00:22.500
JOOST DE VALK: Es un placer para mí
presentarles a nuestro próximo orador,

00:00:22.500 --> 00:00:25.750 
Mark Steadman, quien nos
hablará sobre una guía práctica

00:00:25.750 --> 00:00:27.500
para la accesibilidad automatizada.

00:00:29.170 --> 00:00:32.130
Mark es el director de
ingeniería de software para accesibilidad móvil

00:00:32.130 --> 00:00:33.870
en Fidelity Investments.

00:00:33.870 --> 00:00:38.410
Y con un fervor por
la automatización de la accesibilidad y una fuerte defensa

00:00:38.410 --> 00:00:42.960
para que los desarrolladores prioricen
la accesibilidad, Mark tiene una misión

00:00:42.960 --> 00:00:47.170
para que el
contenido web y móvil sea accesible para todos.

00:00:47.170 --> 00:00:51.340
Sólo una pequeña misión,
no un gran esfuerzo.

00:00:51.340 --> 00:00:55.240
Su enfoque principal gira en torno a
la colaboración con los equipos de desarrollo

00:00:55.240 --> 00:00:57.470
para integrar la accesibilidad,
y es tan agradable.

00:00:57.470 --> 00:01:00.100
Él es como el tercer
orador que estoy presentando.

00:01:00.100 --> 00:01:02.140
Todos ellos trabajan junto
con equipos de desarrollo.

00:01:02.140 --> 00:01:05.580
Realmente me encanta ver eso.

00:01:05.580 --> 00:01:08.910
Él consideró eso como un
componente crucial en el desarrollo

00:01:08.910 --> 00:01:11.430
y los procesos de integración 
continuos.

00:01:11.430 --> 00:01:13.840
Él no sólo ha sido 
pionero en la creación de

00:01:13.840 --> 00:01:17.850
soluciones de accesibilidad automatizadas,
sino que también ha sido pieza fundamental

00:01:17.850 --> 00:01:20.600
en la incorporación de estas
soluciones en el tejido

00:01:20.600 --> 00:01:23.960
de los equipos de desarrollo y
las organizaciones para las que ha trabajado.

00:01:23.960 --> 00:01:28.120
Únanse a mí para darle una
cálida bienvenida a Mark Steadman.

00:01:28.120 --> 00:01:29.910
Mark, adelante.

00:01:29.910 --> 00:01:30.960
MARK STEADMAN: Increíble.

00:01:30.960 --> 00:01:31.280
Bien.

00:01:31.280 --> 00:01:33.600
Bueno, para mí
es un buenos días para todos.

00:01:33.600 --> 00:01:37.650
Son las 6 de la mañana y acabo de tomar un café, así que
será mejor que todos se anden con cuidado ahora mismo

00:01:37.650 --> 00:01:42.220
porque podría estar funcionando a
toda máquina ya que estoy lleno

00:01:42.220 --> 00:01:42.670
de café.

00:01:42.670 --> 00:01:46.390
Buenos días, buenas tardes, buenas
noches, sea cual fuera el horario.

00:01:46.390 --> 00:01:47.600
Esto es increíble.

00:01:47.600 --> 00:01:50.414
Para mí, en Estados Unidos,
esto es empezar el día

00:01:50.415 --> 00:01:52.290
con accesibilidad automatizada.

00:01:52.290 --> 00:01:56.610
Así que no podría estar más emocionado de
tener esta charla con todos ustedes hoy.

00:01:56.610 --> 00:01:59.710
Y para comenzar a ponernos
en marcha porque tenemos muchas cosas

00:01:59.710 --> 00:02:01.820
que cubrir en un corto período de
tiempo, lo que normalmente es

00:02:01.820 --> 00:02:02.680
como doy todas mis charlas.

00:02:02.680 --> 00:02:05.880
Así que de nuevo, muy rápido,
Mark Steadman, solo quiero

00:02:05.880 --> 00:02:07.350
agregar estas cosas
aquí muy rápido.

00:02:07.350 --> 00:02:10.070
Si quieres seguirme en
Twitter o X o lo que sea

00:02:10.070 --> 00:02:15.120
a este ritmo, soy
@steady, S-T-E-A-D-Y 5063.

00:02:15.120 --> 00:02:18.630
luego también me podrás encontrar en
LinkedIn con Mark Steadman

00:02:18.630 --> 00:02:20.470
o simplemente mark_steady si
quieres buscarme.

00:02:21.490 --> 00:02:25.370
Así que los objetivos de aprendizaje
para esta charla.

00:02:25.370 --> 00:02:28.350
Y me encanta hacer esto porque esta
conversación es una de esas

00:02:28.350 --> 00:02:30.540
que me apasiona mucho.

00:02:30.540 --> 00:02:33.920
Por qué la automatización de la accesibilidad es
importante para construir una base

00:02:33.920 --> 00:02:37.220
de accesibilidad en el
ciclo de vida de desarrollo?

00:02:37.220 --> 00:02:38.830
¿Por qué aumentó su popularidad?

00:02:38.830 --> 00:02:42.210
Y los problemas que surgieron
con debido a esa misma popularidad.

00:02:42.210 --> 00:02:45.900
Cómo usar efectivamente LinkedIn
como el primer paso en el camino.

00:02:45.900 --> 00:02:47.240
¿Y por qué es un
buen punto de partida?

00:02:47.240 --> 00:02:49.692
Y luego cómo
utilizar eficazmente las bibliotecas de prueba

00:02:49.693 --> 00:02:50.820
y pruebas de regresión

00:02:50.820 --> 00:02:53.030
para garantizar que
el contenido sea accesible.

00:02:53.030 --> 00:02:55.570
Ahora, esto parece mucho,
pero a medida que avancemos en esto,

00:02:55.570 --> 00:02:57.020
Lo lo iré desglosando
poco a poco

00:02:57.020 --> 00:03:00.460
para hacerlo un poco más
simple y fácil de consumir

00:03:00.460 --> 00:03:02.790
para aquellos que quizás no estén
familiarizados con los equipos de desarrollo,

00:03:02.790 --> 00:03:04.290
o los procesos de desarrollo.

00:03:04.290 --> 00:03:06.820
Y también para aquellos que son
desarrolladores, que se preguntan,

00:03:06.820 --> 00:03:10.420
¿Cómo puedo incorporar esto correctamente
para incluir accesibilidad

00:03:10.420 --> 00:03:11.710
como parte del
ciclo de vida de mis desarrollos?

00:03:13.070 --> 00:03:16.130
Accesibilidad y desplazamiento a la izquierda.

00:03:16.130 --> 00:03:20.820
Para entender cómo la automatización para
la accesibilidad llegó a eso,

00:03:20.820 --> 00:03:23.160
hay que entender
hacia dónde se fue la industria.

00:03:23.160 --> 00:03:26.240
La mayoría de la gente probablemente esté
familiarizada con ésto, pero esto es un poco

00:03:26.240 --> 00:03:27.470
de buen contexto
para todos aquí.

00:03:27.470 --> 00:03:32.440
Entonces, el cambio a la izquierda fue la idea
popularizada por la industria DevOps,

00:03:32.440 --> 00:03:37.550
donde dijimos: "Hey, es más barato
encontrar y corregir errores antes

00:03:37.550 --> 00:03:40.370
en el ciclo de vida del desarrollo, ¿cierto?"
sentido común.

00:03:40.370 --> 00:03:44.450
Sin embargo, durante mucho tiempo,
ese no siempre fue el caso.

00:03:44.450 --> 00:03:47.260
Lo que era el caso, era que haríamos
una especie de módulo en cascada

00:03:47.260 --> 00:03:52.800
o un modelo donde crearíamos,
subiríamos, lanzaríamos a producción,

00:03:52.800 --> 00:03:54.200
y corregiríamos el contenido hasta después.

00:03:54.200 --> 00:03:58.280
Bueno, la industria DevOps dijo,
no, cambiemos este contexto a la izquierda

00:03:58.280 --> 00:04:00.600
para que podamos corregir
errores antes y con un menor costo.

00:04:00.600 --> 00:04:03.320
Entonces lo que tengo en la
pantalla es una imagen

00:04:03.320 --> 00:04:07.470
que básicamente dice que creas,
planificas, monitoreas, configuras,

00:04:07.470 --> 00:04:10.100
liberas, empaquetas, verificas
y luego simplemente se repite

00:04:10.100 --> 00:04:10.860
en un bucle infinito.

00:04:10.860 --> 00:04:12.650
Porque eso es esencialmente
el desplazamiento a la izquierda.

00:04:12.650 --> 00:04:16.180
Constantemente estás corrigiendo errores,
constantemente estás creando contenido,

00:04:16.180 --> 00:04:18.840
y ayuda desde
un punto de vista ágil.

00:04:18.840 --> 00:04:22.900
Bueno, cuando esto empezó a hacerse
muy popular, surgió la idea,

00:04:22.900 --> 00:04:25.980
¿Cómo podría encajar 
la accesibilidad en este modelo?

00:04:25.980 --> 00:04:29.520
Porque la accesibilidad desde hace
mucho tiempo siempre ha sido,

00:04:29.520 --> 00:04:32.790
o lo sigue siendo,
arreglémoslo después del hecho.

00:04:32.790 --> 00:04:35.850
Estoy seguro de que todos los que están aquí ahora,
están seguramente pensando.

00:04:35.850 --> 00:04:37.180
Lo he escuchado miles de veces.

00:04:37.180 --> 00:04:37.680
Es verdad.

00:04:37.680 --> 00:04:39.990
Siempre ha sido el hecho de
que lo arreglaremos más tarde.

00:04:41.220 --> 00:04:46.460
Pero con este cambio, pensamos:
¿Podemos encajar en esto?

00:04:46.460 --> 00:04:49.830
Entonces llegó el auge de
la accesibilidad automatizada.

00:04:49.830 --> 00:04:51.650
Y soy un gran fan de Star Wars.

00:04:51.650 --> 00:04:53.520
Sé que tengo la cosa de WordPress
aquí atrás, pero si pudieran ver.

00:04:53.520 --> 00:04:54.980
Tengo mil
sables de luz detrás de mí,

00:04:54.980 --> 00:04:56.790
un montón de
artículos diferentes de Star Wars.

00:04:56.790 --> 00:05:00.450
Así que hice este logo que decía,
"guerras callejeras, el auge de la automatización"

00:05:00.450 --> 00:05:03.770
usando la fuente tipográfica de Star Wars, porque
eso es esencialmente lo que era.

00:05:03.770 --> 00:05:06.640
La automatización de la accesibilidad
se convirtió en un fenómeno que se ajustó a este modelo.

00:05:06.640 --> 00:05:12.270
Todo, desde bibliotecas de accesibilidad, 
extensiones, utilidades auxiliares,

00:05:14.790 --> 00:05:17.120
lo que sea, obtuvo lo suyo.

00:05:17.120 --> 00:05:20.522
Y con esto, 
intentamos

00:05:20.523 --> 00:05:23.400
arreglar tantos huecos como fuera posible.

00:05:23.400 --> 00:05:26.230
Entonces, con todos los diferentes
lenguajes de desarrollo, marcos de trabajo,

00:05:26.230 --> 00:05:29.500
con todo eso, tratamos de ajustar
este modelo para que pudiéramos obtener

00:05:29.500 --> 00:05:32.850
la mayor accesibilidad automatizada
posible en esos procesos.

00:05:32.850 --> 00:05:36.390
Y sobre el papel, luce maravilloso.

00:05:36.390 --> 00:05:39.070
Esto tiene enormes
beneficios.

00:05:39.070 --> 00:05:41.520
Es una integración fácil 
y rápida de la accesibilidad

00:05:41.520 --> 00:05:42.720
en el ciclo de vida de desarrollo.

00:05:42.720 --> 00:05:43.940
¿Es perfecto?

00:05:43.940 --> 00:05:44.930
Absolutamente no.

00:05:44.930 --> 00:05:47.610
No, esto es sólo una
cantidad mínima o una cantidad pequeña,

00:05:47.610 --> 00:05:49.460
probablemente el tercio inferior
de los problemas accesibles.

00:05:49.460 --> 00:05:53.460
Sin embargo, encaja perfectamente
en cualquier proceso ágil que

00:05:53.460 --> 00:05:55.080
estemos haciendo por la accesibilidad.

00:05:55.080 --> 00:05:58.360
Así que realmente es una victoria fácil
porque no hay discusión.

00:05:58.360 --> 00:05:59.840
desde el lado del desarrollador.

00:05:59.840 --> 00:06:02.560
Solo digo: Hey, tenemos que
agregar esto y encaja bien

00:06:02.560 --> 00:06:04.310
en el sistema que estamos haciendo.

00:06:04.310 --> 00:06:06.970
Ayuda a desarrollar el conocimiento 
de los desarrolladores sobre accesibilidad.

00:06:06.970 --> 00:06:09.440
La mayoría de las herramientas automatizadas vienen
con sus propios elementos de conocimiento.

00:06:09.440 --> 00:06:11.520
o te vinculan a elementos de conocimiento
que te ayudarán con eso.

00:06:12.540 --> 00:06:15.310
Lo creas o no, impone
buenas prácticas de desarrollo de Interfaz de Usuario (UI).

00:06:15.310 --> 00:06:19.970
Si pudiera ver a todos aquí y
verlos a todos en la pantalla ahora mismo,

00:06:19.970 --> 00:06:22.690
todo el mundo se pondría de cabeza
cuando dijera: "El sub div

00:06:22.690 --> 00:06:23.690
no es bueno".

00:06:24.650 --> 00:06:27.720
Esto realmente ayuda a implementar
buenas prácticas de desarrollo de Interfaz de Usuario (UI).

00:06:29.100 --> 00:06:30.950
Permite una aplicación accesible 
para que se puedan utilizar

00:06:30.950 --> 00:06:36.370
las pipas de acciones de GitHub
y comenzar a construir una cultura

00:06:36.370 --> 00:06:37.560
que incluya accesibilidad.

00:06:37.560 --> 00:06:40.480
Me escucharán decir esto
una y otra vez en esta plática.

00:06:40.480 --> 00:06:42.026
Esa es la pieza más grande

00:06:42.027 --> 00:06:44.810
para lograr una adecuada 
automatización de la accesibilidad

00:06:44.810 --> 00:06:48.220
Si lo haces mal, pierdes gente
rápidamente, pero cuando lo haces bien,

00:06:48.220 --> 00:06:51.160
ayuda a establecer esa base
para construir una cultura

00:06:51.160 --> 00:06:53.840
de accesibilidad a lo largo del tiempo.

00:06:53.840 --> 00:06:54.850
Ese es el objetivo final.

00:06:54.850 --> 00:06:58.380
Sí, la automatización es un
punto de partida, pero puedes ayudar a inculcarlo

00:06:58.380 --> 00:07:00.900
en tu cultura desde el
lado del desarrollo, fácilmente

00:07:00.900 --> 00:07:02.440
si lo haces bien.

00:07:02.440 --> 00:07:05.080
Si lo haces mal, puedes
perder gente relativamente rápido,

00:07:05.080 --> 00:07:07.690
pero esos son los grandes beneficios
de la accesibilidad automatizada.

00:07:07.690 --> 00:07:09.700
Entonces se estarán diciendo a
sí mismos, Mark, eso es genial.

00:07:09.700 --> 00:07:10.380
¿Cuál es el problema?

00:07:10.380 --> 00:07:13.410
¿Por qué siquiera estoy aquí hablando con ustedes
ahora mismo? ¿Cuál es el problema?

00:07:14.800 --> 00:07:15.650
Bueno, ésto es un gran problema.

00:07:15.650 --> 00:07:17.980
Se convirtió en una sobrecarga de automatización.

00:07:17.980 --> 00:07:20.320
Lo que tengo en la pantalla son
solo un montón de logotipos diferentes

00:07:20.320 --> 00:07:22.820
para un montón de extensiones diferentes
que hacen un montón de cosas diferentes,

00:07:22.820 --> 00:07:25.490
pero de manera realmente holística
todas hacen la misma cosa.

00:07:25.490 --> 00:07:28.740
Comprueban problemas de accesibilidad 
de forma automatizada.

00:07:30.450 --> 00:07:31.610
Esto es lo que pasó.

00:07:31.610 --> 00:07:36.960
Nos emocionamos demasiado por hacer
un montón de automatización,

00:07:36.960 --> 00:07:38.970
adaptar estos ciclos de vida,
adaptar estos productos,

00:07:38.970 --> 00:07:43.170
y lo que terminó sucediendo
fue que terminamos con una sobrecarga.

00:07:43.170 --> 00:07:46.010
Y los desarrolladores de todos los lugares con los que
hablaba, cada equipo

00:07:46.010 --> 00:07:50.080
con quien hablé diría: 
¿Por dónde diablos empiezo?

00:07:50.080 --> 00:07:51.560
Porque no lo sé.

00:07:51.560 --> 00:07:52.770
Hay tanto por ahí.

00:07:52.770 --> 00:07:53.760
No sé qué usar.

00:07:53.760 --> 00:07:54.530
¿Qué es lo mejor?

00:07:54.530 --> 00:07:56.930
¿Cómo encaja en mi equipo?
Lo que sea que es.

00:07:56.930 --> 00:07:59.580
Así que terminamos con múltiples
bibliotecas de accesibilidad de código abierto,

00:07:59.580 --> 00:08:03.360
algunos de los más destacados, XCOR,
Pali, extensiones de navegador, Wave,

00:08:03.360 --> 00:08:06.740
Lighthouse, Microsoft Insights,
Act Step Tools, ¿verdad?

00:08:06.740 --> 00:08:10.710
Hay un montón de linters
que comienzan a agregar reglas de accesibilidad.

00:08:10.710 --> 00:08:14.610
y todos decían: "Está
ESLint, Acts Linter, está ASLint,

00:08:14.610 --> 00:08:16.190
Hay muchos
diferentes por ahí.

00:08:16.190 --> 00:08:20.750
Y entonces, como desarrolladores,
todos miran esto y dicen:

00:08:20.750 --> 00:08:22.030
¿Por qué hay tanto?

00:08:22.030 --> 00:08:24.070
Ni siquiera sé por dónde empezar.

00:08:24.070 --> 00:08:27.060
Porque aunque para
la mayoría de nosotros que estamos escuchando

00:08:27.060 --> 00:08:29.490
en este momento, probablemente seamos
defensores de la accesibilidad y digamos,

00:08:29.490 --> 00:08:32.130
es obvio, simplemente elige el
que mejor se ajuste a tus cosas y listo.

00:08:32.130 --> 00:08:33.900
No es tan obvio para
alguien que no sabe mucho

00:08:33.900 --> 00:08:34.730
sobre accesibilidad.

00:08:34.730 --> 00:08:38.140
Entonces lo verán y dirán:
Esto es demasiado, estoy fuera.

00:08:38.140 --> 00:08:40.720
Cuántas veces he oído
a alguien decir: "Esto es demasiado,

00:08:40.720 --> 00:08:43.190
ni siquiera supe por dónde
empezar, así que simplemente me dí por vencido".

00:08:43.190 --> 00:08:45.320
Muchas veces, lo creas o no.

00:08:45.320 --> 00:08:50.110
Entonces tenemos que adoptar un
enfoque diferente para poder

00:08:50.110 --> 00:08:55.920
lidiar con esta sobrecarga y
panorama turbio que tenemos ahí afuera;

00:08:55.920 --> 00:08:59.200
para los desarrolladores esa
accesibilidad es demasiado.

00:08:59.200 --> 00:09:01.250
La accesibilidad automatizada
es simplemente demasiado.

00:09:01.250 --> 00:09:03.840
Entonces, ¿cuál es la solución?

00:09:05.100 --> 00:09:06.990
Están en un enfoque práctico
a la accesibilidad automatizada, ¿cierto?

00:09:06.990 --> 00:09:08.220
Entonces Mark, dime la solución:

00:09:09.370 --> 00:09:10.560
Es la automatización por fases.

00:09:11.770 --> 00:09:16.170
He tenido mucha
suerte haciendo esto,

00:09:16.170 --> 00:09:19.370
y tengo algunos casos de uso realmente buenos
para hacer esto y asegurarme

00:09:19.370 --> 00:09:20.480
que lo logramos.

00:09:20.480 --> 00:09:26.160
Lo más importante es
lograr una automatización adecuada.

00:09:26.160 --> 00:09:31.450
Y ejecutarla es llevarla a cabo correctamente
y suena un poco gracioso,

00:09:31.450 --> 00:09:35.700
pero cuando se trata de implementar una
automatización por fases, pueden ver esto

00:09:35.700 --> 00:09:38.140
y decir: "Mark, esto toma demasiado tiempo".

00:09:38.140 --> 00:09:39.150
Sí, tienen toda la razón.

00:09:39.150 --> 00:09:40.410
Toma algo de tiempo.

00:09:40.410 --> 00:09:44.950
Pero si se hace bien, se mantiene y
perdura dentro de la organización

00:09:44.950 --> 00:09:46.550
con el equipo de desarrolladores.

00:09:46.550 --> 00:09:50.310
Por lo tanto, la introducción gradual garantiza que
no se produzca una sobrecarga en el desarrollador

00:09:51.450 --> 00:09:55.340
y construimos una estrategia en torno a eso
que forma parte de las fases

00:09:55.340 --> 00:09:56.190
también.

00:09:56.190 --> 00:10:00.170
Así que son básicamente tres
fases con una fase cero.

00:10:00.170 --> 00:10:03.310
La fase uno es el análisis de errores, la fase dos
son las bibliotecas de pruebas automatizadas,

00:10:03.310 --> 00:10:07.880
la fase tres son pruebas de regresión automatizadas
y la fase cero son extensiones.

00:10:07.880 --> 00:10:10.710
Ahora llegaré a esa fase cero y
por qué la llamo fase cero casi al final

00:10:10.710 --> 00:10:14.200
a medida que avanzamos, pero profundicemos
primero porque esto es

00:10:14.200 --> 00:10:18.100
donde se pone realmente
jugoso y asombroso.

00:10:18.100 --> 00:10:20.120
Fase uno: Linting.

00:10:20.120 --> 00:10:22.400
Para aquellos que no lo saben, 
un linter es una herramienta

00:10:22.400 --> 00:10:27.440
que analiza estáticamente el código fuente
para señalar errores y fallas de desarrollo.

00:10:27.440 --> 00:10:31.360
Así que mientras estoy desarrollando contenido,
me mostrará los errores

00:10:31.360 --> 00:10:35.020
que estoy haciendo
estáticamente dentro de mi HTML.

00:10:35.020 --> 00:10:37.880
Algunas personas lo usan para
JavaScript, Java,

00:10:37.880 --> 00:10:39.890
existen varias
herramientas de linting diferentes

00:10:39.890 --> 00:10:41.410
para muchas cosas diferentes.

00:10:41.410 --> 00:10:44.260
Pero es un
analizador estático de código.

00:10:45.460 --> 00:10:47.880
Los beneficios del linting accesible.

00:10:47.880 --> 00:10:50.510
Se pueden detectar
problemas de accesibilidad de forma temprana.

00:10:51.550 --> 00:10:54.200
Uno desarrolla
conocimientos sobre accesibilidad para sus desarrolladores

00:10:54.200 --> 00:10:56.440
a medida que ellos generan código,
en lugar de más tarde.

00:10:56.440 --> 00:10:59.520
Permite a los equipos construir
puertas accesibles en los commits.

00:10:59.520 --> 00:11:03.950
Lo que quiero decir con eso es que, digamos que
estoy programando con mi compañero de equipo,

00:11:03.950 --> 00:11:07.890
Programo algún código, lo empujo,
puedo ver mis errores de Linting

00:11:07.890 --> 00:11:10.720
y tengo que regresar y arreglarlos,
antes de que pueda

00:11:10.720 --> 00:11:12.740
empujar ese código allí.

00:11:12.740 --> 00:11:17.030
Y lo mejor del
linting es que es personalizable

00:11:17.030 --> 00:11:19.090
al marco de trabajo
en el que se esté desarrollando.

00:11:19.090 --> 00:11:20.800
Esa es la razón número uno
por la que funciona.

00:11:20.800 --> 00:11:25.120
Ahora, la pieza más grande es la
última pieza de ahí, personalizar

00:11:25.120 --> 00:11:27.440
al marco de trabajo
en el que se está desarrollando.

00:11:27.440 --> 00:11:28.670
Esa es la parte realmente genial.

00:11:28.670 --> 00:11:30.650
Cuando se comienza a juntar todo esto,
uno puede darse cuenta

00:11:30.650 --> 00:11:37.140
¿Qué están usando sus equipos?
¿Usan React, Angular, Vue?

00:11:37.140 --> 00:11:40.290
O incluso cualquier otro tipo de pieza,
se puede usar esto a lo largo del camino.

00:11:40.290 --> 00:11:44.000
Y lo realmente asombroso es que
mientras construyo con Linting,

00:11:44.000 --> 00:11:45.730
Puedo encontrar el Linter
que se ajuste a eso,

00:11:45.730 --> 00:11:47.550
y te garantizo que ellos
tendrán reglas de accesibilidad.

00:11:47.550 --> 00:11:52.050
Voy a demostrarles eso a
todos porque esta es la parte

00:11:52.050 --> 00:11:52.710
que más me gusta.

00:11:52.710 --> 00:11:57.840
Voy a pasar
rápidamente a nuestra demostración de Linting.

00:11:57.840 --> 00:12:03.060
Déjenme llegar. Ahí vamos.

00:12:03.060 --> 00:12:04.060
Está bien.

00:12:04.970 --> 00:12:08.750
Lo que tengo aquí es
mi encantador proyecto React.

00:12:08.750 --> 00:12:11.160
Tengo que contar los antecedentes
porque este es mi proyecto favorito.

00:12:11.160 --> 00:12:12.190
de todos los tiempos.

00:12:12.190 --> 00:12:14.160
Este es un emporio de sables de luz.

00:12:14.160 --> 00:12:16.260
Entonces compras sables de luz
desde el sitio web.

00:12:16.260 --> 00:12:19.390
Y este proyecto de React
lo utilicé como que para cada una

00:12:19.390 --> 00:12:21.330
de mis presentaciones
que hice hace años.

00:12:21.330 --> 00:12:22.700
Ésta es genial.

00:12:22.700 --> 00:12:27.590
Pero en este proyecto, tengo un
componente, que es un artículo del carrito.

00:12:27.590 --> 00:12:30.740
Entonces, es sólo un elemento que
en esencia sólo tiene una imagen.

00:12:30.740 --> 00:12:34.210
Tiene un encabezado para describir
cuál es de hecho el producto,

00:12:34.210 --> 00:12:35.110
una pequeña descripción.

00:12:35.110 --> 00:12:39.680
Y luego puedo agregar el clic "más
detalles" o puedo comprarlo nuevamente

00:12:39.680 --> 00:12:40.480
Eso es todo.

00:12:40.480 --> 00:12:41.170
Enlace sencillo.

00:12:41.170 --> 00:12:43.820
Piensen como un
artículo del carrito de Amazon donde, de izquierda a derecha,

00:12:43.820 --> 00:12:48.750
hay una descripción de la imagen y luego
botones en el extremo derecho.

00:12:48.750 --> 00:12:55.630
Ahora mismo usando React,
de hecho estoy usando JSX a11y Linter.

00:12:57.110 --> 00:13:00.560
Este Linter tiene específicamente
reglas de accesibilidad para ESLint.

00:13:01.680 --> 00:13:04.580
ESLint es probablemente uno de
los Linters más populares

00:13:04.580 --> 00:13:06.760
que existen ahí afuera ahora mismo.

00:13:06.760 --> 00:13:09.990
En éste, tiene un subconjunto
de reglas de accesibilidad.

00:13:09.990 --> 00:13:13.740
Entonces digamos que soy un desarrollador
de este componente de elemento del carrito,

00:13:13.740 --> 00:13:16.600
si miro esta pantalla ahora
mismo, lo que tengo es,

00:13:16.600 --> 00:13:21.120
Tengo un par de líneas onduladas rojas 
en un par de lugares diferentes.

00:13:21.120 --> 00:13:25.270
Entonces, en la línea 11 aquí, tengo un div
que es un contenedor de imagen que

00:13:25.270 --> 00:13:28.060
por alguna razón este desarrollador
quería ocultar algo.

00:13:28.060 --> 00:13:29.180
Pero eso no quedó muy bien.

00:13:29.180 --> 00:13:31.720
Entonces dijeron que aria-hide es igual a verdadero.

00:13:31.720 --> 00:13:33.060
Sí, aria-hide no es verdad.

00:13:33.060 --> 00:13:36.810
Entonces, si paso el cursor sobre
esto, dirá aria-hide.

00:13:36.810 --> 00:13:38.030
Ésto no es un atributo.

00:13:38.030 --> 00:13:39.360
Ésto es un atributo aria válido.

00:13:39.360 --> 00:13:41.500
¿Quisiste usar
aria-hidden o aria-live?

00:13:41.500 --> 00:13:43.060
Y te lo dirá.

00:13:43.060 --> 00:13:45.230
Entonces, lo que es realmente genial es que,
ahora, si soy un desarrollador,

00:13:45.230 --> 00:13:48.030
que realmente no sabe nada, y
digamos que hice una mala búsqueda

00:13:48.030 --> 00:13:53.340
en stack overflow, puedo cambiar esto
a aria-hidden y listo,

00:13:53.340 --> 00:13:54.340
la línea ondulada desapareció.

00:13:55.400 --> 00:13:57.600
Eso es linting, mientras lo programo.

00:13:57.600 --> 00:14:00.540
En esta imagen,
me falta un atributo alt.

00:14:00.540 --> 00:14:02.960
Esto me dirá que las imágenes deben
tener un atributo alt adecuado

00:14:02.960 --> 00:14:05.460
con texto significativo o un
atributo vacío para imágenes decorativas.

00:14:05.460 --> 00:14:08.970
Bueno, en este caso, voy
a adivinar que lo que esta persona quiso hacer

00:14:08.970 --> 00:14:10.700
fué ocultar esto como una imagen alternativa.

00:14:10.700 --> 00:14:13.200
Entonces, le daremos un alt y
listo, la línea ondulada desaparecerá.

00:14:14.300 --> 00:14:17.370
Incluso llega tan lejos como cuando dije
que hace cumplir buenas prácticas de codificación.

00:14:18.660 --> 00:14:19.780
Utilizo un ancla.

00:14:19.780 --> 00:14:23.270
El atributo href es necesario para que
un ancla sea accesible mediante el teclado.

00:14:23.270 --> 00:14:26.300
Hola, ¿cuántas anclas existen
en el medio en este momento

00:14:26.300 --> 00:14:29.490
que básicamente son anclas
que no tienen un href en ellas?

00:14:29.490 --> 00:14:32.430 
Por alguna razón,
no son accesibles desde el teclado al disparar los eventos de clic

00:14:32.430 --> 00:14:32.880
de href.

00:14:32.880 --> 00:14:33.070
¿Por qué?

00:14:33.070 --> 00:14:34.560
No tengo idea.

00:14:35.760 --> 00:14:39.230
Puedo agregar simplemente el href
a donde debe ir.

00:14:40.520 --> 00:14:43.400
Entonces aquí href es igual a; y luego
podría simplemente decir detalles.

00:14:44.460 --> 00:14:45.460
Ups.

00:14:47.680 --> 00:14:49.330
Y listo, hecho.

00:14:50.540 --> 00:14:51.330
Eso es todo.

00:14:51.330 --> 00:14:52.730
Ese es un equipo.

00:14:52.730 --> 00:14:55.000
Es absolutamente así de simple.

00:14:55.000 --> 00:14:59.410
Es lo más fácil que se
puede conseguir para los equipos de desarrollo.

00:14:59.410 --> 00:15:01.670
Y realmente es así de simple.

00:15:01.670 --> 00:15:02.030
Si.

00:15:02.030 --> 00:15:03.170
Podrían estar mirando y
decir, Mark,

00:15:03.170 --> 00:15:04.870
Estas son cuestiones súper simplistas.

00:15:04.870 --> 00:15:05.660
Déjenme decirles esto.

00:15:05.660 --> 00:15:09.530
La encuesta de WebAIM Million
me dice que todas las cosas

00:15:09.530 --> 00:15:12.830
de lo que estamos hablando, en cuanto
a simplicidad se refiere, ¿adivinen qué?

00:15:12.830 --> 00:15:15.900
Hay muchos problemas simples
que están ahora mismo afuera en producción.

00:15:15.900 --> 00:15:17.690
Existen en las páginas de inicio
y en todos los ámbitos.

00:15:17.690 --> 00:15:19.020
Entonces, ¿adivinen qué?

00:15:19.020 --> 00:15:20.790
El linting puede solucionar
esos problemas simples.

00:15:20.790 --> 00:15:23.040
Si implementamos el adecuado,
podemos solucionar esos problemas.

00:15:23.040 --> 00:15:25.770
Y eso es realmente el
linting en pocas palabras.

00:15:25.770 --> 00:15:27.699
Súper simple,
muy sencillo

00:15:27.700 --> 00:15:28.820
para armarlo.

00:15:29.830 --> 00:15:32.980
Y hay muchas
cosas buenas que lo acompañan.

00:15:32.980 --> 00:15:35.090
Existen algunas prácticas recomendadas
que también se relacionan con el linting.

00:15:35.090 --> 00:15:38.150
Entonces, encontrar una biblioteca que
funcione con el conjunto de tecnologías,

00:15:38.150 --> 00:15:41.320
como dije antes, ESLint
es el más popular.

00:15:41.320 --> 00:15:44.660
Tiene la mayor cantidad de integraciones
que existen por allí.

00:15:44.660 --> 00:15:45.610
Así que puedes jalarlos.

00:15:45.610 --> 00:15:47.280
Tiene bibliotecas de accesibilidad 
específicamente

00:15:47.280 --> 00:15:49.530
para cualquier marco de trabajo
que se esté usando.

00:15:49.530 --> 00:15:51.550
Encontrar un conjunto de reglas consistente.

00:15:51.550 --> 00:15:55.440
Lo bueno de esto es que la mayoría de
las bibliotecas de código abierto están basadas

00:15:55.440 --> 00:15:58.320
en axe-core porque es la
biblioteca más popular que está disponible.

00:15:58.320 --> 00:16:00.550
Entonces, si sus equipos
deciden usar axe-core,

00:16:00.550 --> 00:16:02.900
también pueden usar el axe-linter.

00:16:02.900 --> 00:16:04.190
No hay ningún problema
con eso.

00:16:04.190 --> 00:16:04.540
Excelente.

00:16:04.540 --> 00:16:05.440
Es genial.

00:16:05.440 --> 00:16:09.280
Pero el JSX a11y
también usa algunas de las reglas de axe-core.

00:16:09.280 --> 00:16:11.420
La consistencia es clave
porque no quieren

00:16:11.420 --> 00:16:13.850
tener múltiples
conjuntos diferentes de reglas ejecutándose

00:16:13.850 --> 00:16:15.390
hasta el punto dónde los programadores dirán,
no entiendo

00:16:15.390 --> 00:16:18.960
por qué esto es un problema aquí
y no un problema allá.

00:16:18.960 --> 00:16:21.430
Entonces la coherencia es clave.

00:16:21.430 --> 00:16:23.140
Otra mejor práctica
es

00:16:23.140 --> 00:16:24.800
enforzar el linting en los commits.

00:16:24.800 --> 00:16:25.910
Y después construir reglas propias.

00:16:25.910 --> 00:16:26.940
No puedo enfatizar esto lo suficiente.

00:16:26.940 --> 00:16:29.340
Puedes crear tus propias
reglas, lo creas o no.

00:16:29.340 --> 00:16:32.500
Puedes crear tus propias reglas,
agregarlas al linting y verificarlas

00:16:32.500 --> 00:16:36.060
para las cosas que sus equipos de programadores
o su organización quieren verificar.

00:16:36.060 --> 00:16:37.840
Es muy, muy simple.

00:16:37.840 --> 00:16:41.180
Y así se puede ir más allá
un poco más con eso.

00:16:41.180 --> 00:16:42.370
Eso es el linting.

00:16:42.370 --> 00:16:43.480
Fase uno.

00:16:43.480 --> 00:16:48.340
Y nuevamente, permítanme reiterar que todas estas
fases toman tanto tiempo como se necesite.

00:16:48.340 --> 00:16:52.420
Esto no significa que la
primera fase sea un sprint. En absoluto.

00:16:52.420 --> 00:16:55.720
Podría ser que, la fase uno
tarde tres meses en ponerse en marcha.

00:16:55.720 --> 00:16:58.150
y funcionar correctamente con todas las
cosas que estamos hablando aquí

00:16:58.150 --> 00:17:00.010
como las mejores prácticas y
quizás algunas cosas diferentes

00:17:00.010 --> 00:17:02.810
que su organización
o equipo de desarrollo desea hacer.

00:17:02.810 --> 00:17:04.290
Puede que lleve tiempo.

00:17:04.290 --> 00:17:05.540
Está bien.

00:17:05.540 --> 00:17:06.900
Que tome tiempo.

00:17:06.900 --> 00:17:10.860
Queremos que tome tiempo porque
tenemos que hacerlo bien, ¿de acuerdo?

00:17:10.860 --> 00:17:14.360
Entonces, una vez que se completa la fase uno,
pasamos a la fase dos,

00:17:14.360 --> 00:17:16.310
que son las
bibliotecas de accesibilidad automatizadas.

00:17:16.310 --> 00:17:19.480
Y la mayoría de las personas que están aquí
probablemente sean programadores

00:17:19.480 --> 00:17:22.700
o estén haciendo algunas pruebas reales
o creando bibliotecas de pruebas,

00:17:22.700 --> 00:17:25.300
y probablemente estén familiarizados con algunas de
las bibliotecas de accesibilidad automatizadas

00:17:25.300 --> 00:17:26.300
que existen.

00:17:27.560 --> 00:17:30.560 
Las bibliotecas de accesibilidad automatizadas
tienen comprobaciones integradas

00:17:30.560 --> 00:17:33.760
que escanean el contenido de la interfaz de usuario
en busca de problemas de accesibilidad.

00:17:33.760 --> 00:17:38.590
Así, por ejemplo, si tengo un
proyecto de controlador web Selenium

00:17:38.590 --> 00:17:41.260
o un proyecto Puppeteer
– pueden nombrar cualquier tipo

00:17:41.260 --> 00:17:45.310
de controladores diferentes que estén usando,
puedo agregar esa biblioteca.

00:17:45.310 --> 00:17:47.180
Conectarla al
marco de trabajo que estoy usando.

00:17:47.180 --> 00:17:51.980
Y hago un caso de prueba que verifica
si hay algún problema.

00:17:51.980 --> 00:17:54.980
en la página o el
contenido que esté escaneando.

00:17:54.980 --> 00:17:56.770
Nuevamente, esta es una verificación genérica.

00:17:56.770 --> 00:17:59.490
No es nada que vaya
a ir específicamente

00:17:59.490 --> 00:18:02.670
y cambiar el contenido,
como abrir, expandir, contraer secciones,

00:18:02.670 --> 00:18:04.830
o realizar cualquier tipo de acción accesible.

00:18:04.830 --> 00:18:06.250
Simplemente
escaneará genéricamente el contenido.

00:18:06.250 --> 00:18:09.590
Ahora, hace más que
linting porque puede hacer más

00:18:09.590 --> 00:18:12.420
que solo análisis estático
porque la página completamente renderizada

00:18:12.420 --> 00:18:15.560
o el componente completamente renderizado
estará sucediendo en ese momento.

00:18:15.560 --> 00:18:20.230
Pero los beneficios de estas bibliotecas
son sus conjuntos consistentes de reglas.

00:18:20.230 --> 00:18:21.220
Eso es lo más importante.

00:18:21.220 --> 00:18:24.800
Es un conjunto consistente de
reglas que se repiten una y otra vez.

00:18:24.800 --> 00:18:25.840
sobre ese contenido.

00:18:25.840 --> 00:18:31.290
Entonces, si hago uno o dos
casos de prueba, uno para mi página de inicio

00:18:31.290 --> 00:18:34.780
y uno para mi página de inicio de sesión,
se estará ejecutando el mismo conjunto de reglas

00:18:34.780 --> 00:18:35.420
en ambos.

00:18:35.420 --> 00:18:39.240
Con ello, obtengo resultados 
y escaneos consistentes.

00:18:39.240 --> 00:18:42.160
Puedo construir portales de nuevo,
lo cual es genial cuando digo portales,

00:18:42.160 --> 00:18:46.940
cuando estoy subiendo código para,
digamos, una PR a GitHub

00:18:46.940 --> 00:18:51.510
o estoy enviando el código para revisión de código
o lo estoy enviando a producción.

00:18:51.510 --> 00:18:53.100
Puedo poner un portal en esto
y decir que espero que no hayan

00:18:53.100 --> 00:18:55.030
violaciones de accesibilidad.

00:18:55.030 --> 00:18:59.600
Y es rápido y fácil de agregar a
la estructura de prueba de UI actual.

00:19:00.940 --> 00:19:02.680
Probablemente estén diciendo: Bueno,
Mark, dijiste que es rápido y fácil.

00:19:02.680 --> 00:19:04.630
para el linting también,
el linting es aún más rápido.

00:19:04.630 --> 00:19:11.290
Esto sigue siendo sencillo de agregar
a un proceso de prueba de UI.

00:19:11.290 --> 00:19:14.150
La diferencia es que cuando
se hace esto, toma un poco

00:19:14.150 --> 00:19:15.890
de trabajo configurar esto
al principio, lo cual es

00:19:15.890 --> 00:19:19.140
donde habrá algo de resistencia, 
si se llega alguna vez a este punto.

00:19:19.140 --> 00:19:20.370
Bueno, esto va a llevar tiempo.

00:19:20.370 --> 00:19:21.340
Lo hará.

00:19:21.340 --> 00:19:25.440
Pero les voy a mostrar lo
sencillo que puede ser configurar esto.

00:19:25.440 --> 00:19:28.760
de una manera que es simplemente repetible
y relativamente sencilla

00:19:28.760 --> 00:19:29.290
para construir.

00:19:29.290 --> 00:19:30.060
OK.

00:19:30.060 --> 00:19:36.690
Así que voy a volver a
mi encantadora pieza del emporio de sables de luz.

00:19:36.690 --> 00:19:42.223
Y lo que voy a hacer
es que de hecho me voy a ir

00:19:42.224 --> 00:19:44.520
a una de mis especificaciones.

00:19:44.520 --> 00:19:45.910
Esta especificación es mi caso de prueba aquí.

00:19:46.970 --> 00:19:51.550
Mi primera especificación que está aquí en realidad es
sólo una prueba, déjenme ir

00:19:51.550 --> 00:19:55.880
a mi especificación de pie de página que de hecho,
sólo está probando el componente de del pie de página

00:19:55.880 --> 00:19:57.680
para mi aplicación.

00:19:57.680 --> 00:20:00.210
Nuevamente, estas
bibliotecas de prueba de accesibilidad pueden funcionar

00:20:00.210 --> 00:20:01.030
en múltiples niveles.

00:20:01.030 --> 00:20:04.420
Pueden funcionar dentro de una prueba unitaria,
que sería para cada componente,

00:20:04.420 --> 00:20:06.106
o pueden funcionar en una
prueba a nivel de integración,

00:20:06.107 --> 00:20:08.740
que es todo junto
en la pantalla.

00:20:08.740 --> 00:20:11.840
Cualquiera sea el método que funcione para su
equipo, así es como pueden hacerlo.

00:20:11.840 --> 00:20:14.840
Esa es una parte hermosa de
las bibliotecas de accesibilidad automatizadas.

00:20:14.840 --> 00:20:21.310
Entonces, con esta especificación de pie de página, lo que tengo
es que estoy usando la biblioteca de pruebas React

00:20:21.310 --> 00:20:24.830
para esto, y en esto, configuré
múltiples casos de prueba sólo para verificar.

00:20:24.830 --> 00:20:27.470
Entonces, por ejemplo, tengo una
prueba que simplemente verifica para ver

00:20:27.470 --> 00:20:29.870
si se carga un componente,
tengo una verificación para decir:

00:20:29.870 --> 00:20:32.120
debe haber una cierta
cantidad de listas de elementos

00:20:32.120 --> 00:20:33.790
que están en el pie de página,
así que tengo una lista de enlaces

00:20:33.790 --> 00:20:34.790
en la parte inferior.

00:20:35.610 --> 00:20:40.380
Y encima de eso,
agrego una prueba.

00:20:40.380 --> 00:20:42.763
Pueden llamar a esto
verificación de accesibilidad,

00:20:42.764 --> 00:20:44.840
podrían llamarlo isAccessible,

00:20:44.840 --> 00:20:46.360
Podrían llamarlo
como quieran.

00:20:46.360 --> 00:20:48.470
Nombrarlo consistentemente es la clave.

00:20:48.470 --> 00:20:50.280
Porque cuando nombro mis
cosas, diré

00:20:50.280 --> 00:20:53.130
comprobación de accesibilidad
verificación de accesibilidad para
el componente de pie de página.

00:20:53.130 --> 00:20:56.870
Lo que es grandioso, es que como estoy creando
esto con una biblioteca de accesibilidad,

00:20:56.870 --> 00:20:59.780
Esta de aquí, estoy usando axe-core
para ambos ejemplos.

00:20:59.780 --> 00:21:01.520
Probablemente sea la
más fácil de integrar.

00:21:01.520 --> 00:21:04.140
y cuenta con la mayor cantidad de integraciones.

00:21:04.140 --> 00:21:11.000
Pero mientras desarrollo esto,
puedo simplemente hacer el mismo caso de prueba

00:21:11.000 --> 00:21:13.950
a través de múltiples especificaciones.

00:21:13.950 --> 00:21:15.470
Esa es la
parte hermosa de esto.

00:21:15.470 --> 00:21:18.470
Puedo crearlo y
hacerlo consistente hasta donde sea posible.

00:21:18.470 --> 00:21:23.860
cuando integro esto,
literalmente es copiar y pegar.

00:21:23.860 --> 00:21:24.450
Así de simple.

00:21:24.450 --> 00:21:26.050
Te voy a mostrar cómo.

00:21:26.050 --> 00:21:28.710
Entonces, esta verificación de accesibilidad
que tengo aquí.

00:21:28.710 --> 00:21:30.510
Es específica para
la biblioteca de pruebas de React,

00:21:30.510 --> 00:21:33.790
pero esencialmente tomo el
contenedor que tiene el componente,

00:21:33.790 --> 00:21:37.500
Renderizo mi pie de página,
luego ejecuto axe.run,

00:21:37.500 --> 00:21:40.400
que es la forma típica de
ejecutar Axe contra el contenedor.

00:21:40.400 --> 00:21:43.710
Así que ahora voy a ejecutar esas
reglas de axe-core contra esto.

00:21:43.710 --> 00:21:45.810
Tengo este reporteador personalizado
que está aquí, pero si quieren

00:21:45.810 --> 00:21:48.630
tener un reporteador se
puede, aunque no es necesario.

00:21:48.630 --> 00:21:53.640
Y luego espero, mis expectativas
son de hecho mi caso de prueba

00:21:53.640 --> 00:21:56.360
los resultados.violaciones, que sería
la violación del componente,

00:21:56.360 --> 00:21:59.130
Espero que la longitud
de eso sea cero.

00:22:00.370 --> 00:22:01.710
Eso es.

00:22:01.710 --> 00:22:03.050
Y eso es todo.

00:22:03.050 --> 00:22:08.610
Lo realmente es genial de esto es
que ahora puedo tomarlo, copiarlo,

00:22:08.610 --> 00:22:09.570
¿Y luego adivinen qué?

00:22:09.570 --> 00:22:11.070
Déjenme mostrarles
rápidamente otro de éstos.

00:22:11.070 --> 00:22:12.250
para que todos puedan verlo.

00:22:12.250 --> 00:22:13.600
Si abro mi componente de encabezado.

00:22:15.220 --> 00:22:16.560
Miren eso.

00:22:16.560 --> 00:22:18.390
Literalmente es exactamente lo mismo.

00:22:18.390 --> 00:22:21.020
La única diferencia podría ser
que cambiamos el nombre.

00:22:21.020 --> 00:22:23.260
si tienen grabaciones
o cosas así.

00:22:23.260 --> 00:22:24.190
Pero eso es todo.

00:22:24.190 --> 00:22:26.050
Es así de simple.

00:22:26.050 --> 00:22:30.110
Una copia y un pegado de ese
caso de prueba si lo configuramos correctamente.

00:22:30.110 --> 00:22:32.960
Si sus casos de prueba están configurados
correctamente, es así de simple.

00:22:32.960 --> 00:22:35.730
Muchas veces, cuando los equipos configuran
estas exitosas bibliotecas de prueba

00:22:35.730 --> 00:22:38.670
dicen: Mark,
Esto es mucho trabajo.

00:22:38.670 --> 00:22:40.050
Realmente no lo es.

00:22:40.050 --> 00:22:42.270
Es tan simple como configurar
correctamente el caso de prueba.

00:22:42.270 --> 00:22:45.960
en una única cosa, asegurándose de que funciona
y luego ejecutarlo.

00:22:45.960 --> 00:22:46.760
Así de simple.

00:22:46.760 --> 00:22:50.330
Así que también puedo ejecutar esto muy
rápidamente, sólo la especificación del pie de página.

00:22:50.330 --> 00:22:53.530
Déjenme ejecutar esto.

00:22:53.530 --> 00:22:57.340
Ahora, les advierto, porque cada vez que
termino haciendo algo como esto

00:22:57.340 --> 00:22:59.170
en una demostración en vivo,
especialmente temprano en la mañana,

00:22:59.170 --> 00:23:00.920
mi computadora aún
no ha tomado su café.

00:23:00.920 --> 00:23:02.740
Así que estoy seguro de que
probablemente será algo así como,

00:23:02.740 --> 00:23:05.110
No tengo ganas de trabajar ahora
mismo, lo cual está bien.

00:23:05.110 --> 00:23:08.310
Puedo pasar a la siguiente
parte después de esto si lo necesito.

00:23:08.310 --> 00:23:12.980
Pero mientras esto se ejecuta, lo que quiero
mostrar es lo simple que es.

00:23:12.980 --> 00:23:15.960
ver los resultados que
surgen de esto también.

00:23:15.960 --> 00:23:19.390
Entonces, si terminé con el
componente, digamos que terminé

00:23:19.390 --> 00:23:21.780
con mis reglas de linting, digo que
esto está listo y digo,

00:23:21.780 --> 00:23:24.450
sí, voy a ejecutar mi
caso de prueba contra esto.

00:23:24.450 --> 00:23:27.650
Bueno, lo que puedo hacer ahora es
tener un reporteador o tenerlo

00:23:27.650 --> 00:23:29.760
en la consola,
que viene con la mayoría

00:23:29.760 --> 00:23:33.280
de las bibliotecas de prueba que se tienen, para
decir, ¿dónde están mis problemas existentes?

00:23:33.280 --> 00:23:35.380
Entonces voy a encontrar mi pie de página.

00:23:35.380 --> 00:23:36.620
Oh, sí,
tenemos muchos problemas aquí.

00:23:37.650 --> 00:23:40.190
Además, aparentemente, Mark debería actualizar
sus cosas porque están desactualizadas.

00:23:40.190 --> 00:23:41.380
Ahí está mi pie de página.

00:23:41.380 --> 00:23:42.820
Ahí está mi caso de prueba.

00:23:42.820 --> 00:23:45.880
Esperaba que results.violation.length
fuera cero.

00:23:45.880 --> 00:23:47.570
Encontré dos problemas de accesibilidad.

00:23:47.570 --> 00:23:50.060
Bueno, ya que tengo un
reporteador personalizado, puedo ir

00:23:50.060 --> 00:23:51.400
aquí muy rápido y
descubrir cuáles son.

00:23:51.400 --> 00:23:52.820
Oh, mira eso.

00:23:52.820 --> 00:23:54.730
Los elementos del formulario no tienen etiquetas.

00:23:54.730 --> 00:23:56.110
Impresionante.

00:23:56.110 --> 00:23:56.690
Lo mismo.

00:23:56.690 --> 00:23:58.170
Dos elementos de formulario
no tienen etiquetas.

00:23:58.170 --> 00:24:02.110
Y, oh, mi lista está incluida
en Recursos Humanos en medio de mi lista.

00:24:02.110 --> 00:24:04.390
Así de simple.

00:24:04.390 --> 00:24:06.150
Así que esas cosas se pueden
cachar en el camino.

00:24:06.150 --> 00:24:08.100
Y ahora puedo tomar
ese mismo caso de prueba

00:24:08.101 --> 00:24:09.850
y replicarlo en todos los ámbitos.

00:24:11.170 --> 00:24:12.170
Así de simple.

00:24:12.860 --> 00:24:14.630
Si lo miramos
desde un nivel de integración,

00:24:14.630 --> 00:24:19.770
sólo como muestra rápida, también tengo
un ejemplo aquí con Selenium.

00:24:19.770 --> 00:24:23.140
Así que nuevamente, simplemente encuentren la
integración axe que deseen,

00:24:23.140 --> 00:24:24.830
axe-webdriverjs.

00:24:24.830 --> 00:24:27.480
Se adapta a cualquier cosa que estés
usando, el controlador mismo

00:24:27.480 --> 00:24:29.030
para obtener instrucciones de configuración.

00:24:29.030 --> 00:24:31.620
Tengo todos mis casos de prueba,
el número total de listados,

00:24:31.620 --> 00:24:32.780
lista de botones renderizados.

00:24:32.780 --> 00:24:36.110
Y luego pruebo, como
ejemplo, ¿es accesible?.

00:24:36.110 --> 00:24:37.230 
¿Adivinen qué?

00:24:37.230 --> 00:24:40.150
Este de aquí es
exactamente el mismo caso de prueba

00:24:40.150 --> 00:24:43.840
a lo largo de todas mis pruebas de integración
porque mis casos de prueba están configurados

00:24:43.840 --> 00:24:48.680
de una manera que cuando se renderizan, dirá,

00:24:48.680 --> 00:24:55.010
la página de capturada es accesible en
la ejecución de prueba. Así de sencillo.

00:24:55.010 --> 00:24:59.560
Entonces, usar bibliotecas de prueba automatizadas
puede parecer una tarea desalentadora,

00:24:59.560 --> 00:25:00.420
pero en realidad no lo es.

00:25:00.420 --> 00:25:04.100
Una vez que se configura y se pone en funcionamiento,
se repiten las mismas pruebas.

00:25:04.100 --> 00:25:06.180
en una estructura que
se ajusta a lo que se está haciendo.

00:25:06.180 --> 00:25:08.110
Mi ejemplo es muy simplista.

00:25:08.110 --> 00:25:09.320
Lo entiendo totalmente.

00:25:09.320 --> 00:25:11.430
Pero en general,
así es como funciona,

00:25:11.430 --> 00:25:13.830
es que se puede
tomar de manera simplista el mismo caso de prueba

00:25:13.830 --> 00:25:15.870
y ejecutarlo una y otra vez.

00:25:15.870 --> 00:25:17.540
Y les dará los resultados
según la manera en que 

00:25:17.540 --> 00:25:18.490
hayan estructurado sus casos de prueba.

00:25:18.490 --> 00:25:23.170
Y eso es a nivel de pruebas unitarias o de integración, 
lo cual es fantástico.

00:25:23.170 --> 00:25:27.700
Así que regresando a mis
encantadores beneficios para estas mejores prácticas.

00:25:29.390 --> 00:25:33.610
La mejor práctica para esto es:
encontrar una integración que se ajuste

00:25:33.610 --> 00:25:35.380
a lo que el equipo de desarrollo
está haciendo.

00:25:35.380 --> 00:25:37.260
Asegúrarse de que los conjuntos de reglas
sean consistentes.

00:25:37.260 --> 00:25:41.500
No quieren utilizar un linting que
utiliza una biblioteca completamente diferente

00:25:41.500 --> 00:25:44.230
a la de axe, o no quieren
usar Pali en un momento dado

00:25:44.230 --> 00:25:47.580
o un conjunto diferente de
pruebas de integración con él.

00:25:47.580 --> 00:25:50.340
La mayoría de las
integraciones de código abierto usan axe-core de todos modos,

00:25:50.340 --> 00:25:54.030
así que no es una prueba difícil de
hacer, pero asegúrense de que estamos usando una

00:25:54.030 --> 00:25:58.160
que se ajuste a la estructura de prueba de UI 
que estamos haciendo.

00:25:58.160 --> 00:26:00.760
Otra mejor práctica es basarse
en el principio de uno-a-uno.

00:26:00.760 --> 00:26:04.210
Hay un principio de uno-a-uno en
las pruebas de UI que dice que para cada pieza

00:26:04.210 --> 00:26:08.440
de la interfaz de usuario, hay un
caso de prueba de accesibilidad emparejado con ella.

00:26:08.440 --> 00:26:11.090
Entonces, ya sea un componente,
una página,

00:26:11.090 --> 00:26:15.230
mano-a-mano asegurarse de que ese
fragmento de código, ese fragmento

00:26:15.230 --> 00:26:17.940
de la interfaz de usuario tenga una
prueba de accesibilidad vinculada.

00:26:17.940 --> 00:26:20.420
Y también probar a
múltiples niveles.

00:26:20.420 --> 00:26:23.980
Acabo de mostrarles todo
esto, pero si pueden probar

00:26:23.980 --> 00:26:27.590
con una biblioteca de accesibilidad a
nivel de unidad y a nivel de integración,

00:26:27.590 --> 00:26:28.680
es fantástico.

00:26:28.680 --> 00:26:30.990
Es un beneficio para todos y en todos los ámbitos.

00:26:30.990 --> 00:26:32.120
Se obtienen todos los
beneficios y todo.

00:26:32.120 --> 00:26:34.850
Entonces, si pueden,
realicen pruebas a múltiples niveles.

00:26:35.930 --> 00:26:40.580
Entonces, fase uno, Linting, fase
dos, bibliotecas de accesibilidad.

00:26:40.580 --> 00:26:41.900
Dirán algo como:
Mark, ¿cuál es la fase tres?

00:26:41.900 --> 00:26:44.570
Porque parece que hemos cubierto
toda la automatización de la accesibilidad

00:26:44.570 --> 00:26:45.570
posible.

00:26:45.990 --> 00:26:47.050
Tarán.

00:26:47.050 --> 00:26:48.050
Pruebas de regresión.

00:26:49.030 --> 00:26:52.740
Entonces, siempre tiendo a recibir
criticas por esto, muchas veces.

00:26:52.740 --> 00:26:56.010
porque cada vez que alguien escucha
que se puede automatizar más de lo que

00:26:56.010 --> 00:26:59.050
hacen las bibliotecas de accesibilidad linting, 
la gente tiende 

00:26:59.050 --> 00:27:02.740
a saltar de inmediato y
decir, oh, no, no se puede.

00:27:02.740 --> 00:27:04.970
Estás hablando de
automatizar todo con eso.

00:27:04.970 --> 00:27:06.030
No lo estoy.

00:27:06.030 --> 00:27:08.900
De lo que estoy hablando es
de que se pueden crear casos de prueba de UI

00:27:08.900 --> 00:27:13.150
que vayan más allá de
las bibliotecas de accesibilidad genéricas.

00:27:13.150 --> 00:27:17.040
Se pueden crear casos de prueba automatizados
que garanticen que la funcionalidad

00:27:17.040 --> 00:27:19.580
del contenido sea accesible.

00:27:19.580 --> 00:27:21.780
Así, por ejemplo,
una sección que se expande y colapsa.

00:27:22.860 --> 00:27:25.640
Usando algo como el linting del axe-core,
simplemente asegurará

00:27:25.640 --> 00:27:30.830
que se tenga el atributo "expanded" igual a falso o verdadero
correctamente escrito

00:27:30.830 --> 00:27:32.920
y colocado como atributo.

00:27:32.920 --> 00:27:37.990
Pero no puede probar la funcionalidad de que
ese estado esté configurado correctamente,

00:27:37.990 --> 00:27:40.810
o que un atributo "hidden" igual a
verdadero esté correctamente asignado

00:27:40.810 --> 00:27:42.950
cuando se abre la
sección expandir/collapsar

00:27:42.950 --> 00:27:44.390
No puede hacer eso.

00:27:44.390 --> 00:27:47.340
Entonces, los beneficios de realizar
pruebas de regresión es,

00:27:47.340 --> 00:27:49.450
que es más fácil depurar
problemas de accesibilidad.

00:27:54.090 --> 00:27:58.200
Es más fácil hacer eso.

00:27:58.200 --> 00:28:00.860
Es incluir las pruebas de accesibilidad
como parte de la definición de "completado".

00:28:00.860 --> 00:28:05.360
Así, por ejemplo, estamos
desarrollando auditorías manuales con esto.

00:28:05.360 --> 00:28:09.030
Entonces, si recibo una auditoría manual que
dice: "Hey, puedo acceder

00:28:09.030 --> 00:28:12.590
al contenido de esa
sección que se expande y colapsa cuando está oculto",

00:28:12.590 --> 00:28:13.260
¿saben qué puedo hacer?

00:28:13.260 --> 00:28:16.200
Puedo escribir una prueba de regresión que
diga que necesito asegurarme de que el estado

00:28:16.200 --> 00:28:19.420
de ese atributo esté funcionando
de la manera que espero.

00:28:19.420 --> 00:28:21.587
¿Está verificando que
se anuncie correctamente?

00:28:21.588 --> 00:28:22.540
¿con un lector de pantalla?

00:28:22.540 --> 00:28:25.760
No, sólo trata de garantizar
que el contenido accesible

00:28:25.760 --> 00:28:28.810
o la funcionalidad accesible de
ese componente está funcionando correctamente.

00:28:28.810 --> 00:28:30.980
Hay una diferencia
entre los dos.

00:28:30.980 --> 00:28:33.260
Porque sí,
puede que existan errores.

00:28:33.260 --> 00:28:35.500
dentro de los
propios lectores de pantalla.

00:28:35.500 --> 00:28:37.870
Puede que existan errores
dentro de nuestro propio código.

00:28:37.870 --> 00:28:41.030
Pero así podremos depurarlos más fácilmente.

00:28:41.030 --> 00:28:43.360
Así nos aseguramos de que el
contenido sea totalmente accesible.

00:28:43.360 --> 00:28:44.460
desde un punto de vista funcional.

00:28:45.500 --> 00:28:47.860
Déjenme hacer una demostración
porque cada vez que intento

00:28:47.860 --> 00:28:49.610
hacer esto, todo el mundo tiende
a quedarse sentado

00:28:49.610 --> 00:28:51.690
y decir: "No creo lo que
Mark me está diciendo ahora mismo".

00:28:51.690 --> 00:28:52.690
Y eso está bien.

00:28:54.300 --> 00:28:55.590
Déjenme darles un ejemplo.

00:28:56.640 --> 00:28:59.200
Este es un
proyecto que tengo en Cypress.

00:28:59.200 --> 00:29:02.450
Cypress es una de las
bibliotecas de pruebas de UI más populares.

00:29:02.450 --> 00:29:03.620
Funciona relativamente de la misma manera.

00:29:03.620 --> 00:29:04.600
Es un probador de integración.

00:29:04.600 --> 00:29:08.840
Pero quiero mostrar un par
de casos de prueba de ejemplo que podemos hacer.

00:29:08.840 --> 00:29:10.110
desde un punto de vista de regresión.

00:29:10.110 --> 00:29:14.550
Digamos que recibo una auditoría manual
que dice: Bueno, el estado "disabled"

00:29:14.550 --> 00:29:17.220
de su botón no está presente.

00:29:17.220 --> 00:29:19.650
Está cambiando de colores,
pero no está allí.

00:29:19.650 --> 00:29:21.670
Como si el atributo "disabled"
no estuviera allí.

00:29:21.670 --> 00:29:23.730
Puedo escribir una
prueba de regresión para eso.

00:29:23.730 --> 00:29:26.030
Entonces, tengo un caso de prueba
en la pantalla que dice:

00:29:26.030 --> 00:29:29.010
Es el estado "disabled" adecuado
para un botón dado.

00:29:30.190 --> 00:29:35.790
Entonces básicamente verifico antes de ingresar
cualquier información en este campo,

00:29:35.790 --> 00:29:37.080
¿Está el botón deshabilitado?

00:29:37.080 --> 00:29:38.160
¿Y debería existir?

00:29:38.160 --> 00:29:39.160
¿Sí o no?

00:29:39.990 --> 00:29:41.290
Genial.

00:29:41.290 --> 00:29:42.210
Entonces espero.

00:29:42.210 --> 00:29:45.150
Escribo algún contenido en campo de entrada.

00:29:45.150 --> 00:29:47.740
En este caso, escribo:
me encanta la accesibilidad.

00:29:47.740 --> 00:29:51.720
Después regreso a ese
botón deshabilitado, invoco el atributo "disabled"

00:29:51.720 --> 00:29:53.350
y dice que no debería existir.

00:29:53.350 --> 00:29:55.990
Listo, hecho,
funcionalidades accesibles implementadas.

00:29:57.180 --> 00:29:58.180
Muy sencillo.

00:29:58.950 --> 00:30:02.790
Lo mismo que hablamos antes,
verificar el colapso del aria-expandido.

00:30:02.790 --> 00:30:05.570
Me encanta usar éste
porque es un gran caso de uso.

00:30:05.570 --> 00:30:06.990
Tengo un switch.

00:30:06.990 --> 00:30:10.790
Verifico si aria-expanded por
defecto es igual a falso 

00:30:10.790 --> 00:30:12.230
cuando está cerrado.

00:30:12.230 --> 00:30:13.630
Luego voy al caso de prueba.

00:30:13.630 --> 00:30:17.950
Digo: "Hey, switch, dispara, haz clic
o toca". Sé que esto

00:30:17.950 --> 00:30:20.320
no tiene teclado
pero lo activo.

00:30:21.420 --> 00:30:24.540
Entro en ello y lo invoco para ver
que aria-expanded debería ser verdadero.

00:30:24.540 --> 00:30:25.860
No es así.

00:30:25.860 --> 00:30:29.040
Luego lo cierro nuevamente y
verifico si dice que es falso.

00:30:29.040 --> 00:30:31.600
Pruebas de regresión, relativamente
directas y simples.

00:30:33.260 --> 00:30:36.740
Puedo verificar para ver si hay
indicadores de foco en los elementos presentes.

00:30:36.740 --> 00:30:38.430
Sí, se puede hacer.

00:30:38.430 --> 00:30:40.870
Voy a hacer una salvedad con esto.

00:30:40.870 --> 00:30:45.650
Sin embargo se debe saber cuál
es el color del contorno usado para el foco;

00:30:45.650 --> 00:30:46.230
y para hacer eso,

00:30:46.230 --> 00:30:47.630
No se puede
verificar eso genéricamente.

00:30:47.630 --> 00:30:48.950
Entonces ya se tiene que saber cuál es.

00:30:48.950 --> 00:30:53.200
Entonces, básicamente, conforme recorro cada uno de
estos botones que están en una lista de menú

00:30:53.200 --> 00:30:56.550
y me enfoco en ellos,
puedo ver el esquema CSS.

00:30:56.550 --> 00:30:58.970
Si sé que
el color de fondo se supone

00:30:58.970 --> 00:31:01.070 
que coincida con un color
específico , ¿adivinen qué?

00:31:01.070 --> 00:31:02.370
Tiene un indicador de foco.

00:31:02.370 --> 00:31:04.700
¿Cuántos sitios
conocen que retroceden?

00:31:04.700 --> 00:31:07.820
y remueven su
indicador de foco porque no lo saben?

00:31:07.820 --> 00:31:08.560
Toneladas.

00:31:08.560 --> 00:31:09.910
Esto puede solucionarlo.

00:31:09.910 --> 00:31:13.560
Si lo saben, asegúrese de que todo el
contenido tenga un indicador de foco.

00:31:14.630 --> 00:31:15.900
A11y se centra en modales.

00:31:15.900 --> 00:31:19.940
¿Cuántos modales conocen
que no fijan el foco correctamente

00:31:19.940 --> 00:31:22.830
en los modales? Toneladas.

00:31:22.830 --> 00:31:24.270
Esto puede solucionarlo.

00:31:24.270 --> 00:31:26.960
Si tengo modales, puedo escribir
pruebas de regresión que se aseguren de que

00:31:26.960 --> 00:31:31.480
cuando active un evento por clic, el
foco vaya hacia o dentro del modal.

00:31:31.480 --> 00:31:33.850
En este caso, simplemente lo reviso para
asegurarme de que vaya al título.

00:31:33.850 --> 00:31:38.330
Cuando lo cierro, el foco vuelve
al disparador que lo activó.

00:31:38.330 --> 00:31:39.040
Pueden hacer eso.

00:31:39.040 --> 00:31:40.610
Pueden escribir
pruebas de regresión para estos.

00:31:41.940 --> 00:31:44.910
Esa es la belleza de
las pruebas de regresión accesibles.

00:31:44.910 --> 00:31:47.820
Sí, llegar a este
estado llevará un tiempo.

00:31:47.820 --> 00:31:51.020
A la fase uno o fase dos, se puede llegar
sin demasiados problemas.

00:31:51.020 --> 00:31:52.280
Puede que lleve algún tiempo.

00:31:52.280 --> 00:31:53.510
La fase tres puede tardar un poco más.

00:31:53.510 --> 00:31:58.650
Pero puedo decirles a todos ahora mismo
que he visto a un par de equipos llegar

00:31:58.650 --> 00:31:59.570
hasta la fase tres.

00:31:59.570 --> 00:32:03.200
Y cuando lo hacen,
si algo retrocede,

00:32:03.200 --> 00:32:05.980
si algo se retira,
o se separa accidentalmente

00:32:05.980 --> 00:32:06.800
del código.

00:32:06.800 --> 00:32:10.930
Lo ven al instante y
evitan toneladas de quejas

00:32:10.930 --> 00:32:13.500
de clientes que dicen: "Hey,
tu contenido es inaccesible".

00:32:13.500 --> 00:32:16.030
Evitan que lleguen toneladas de probabilidades manuales 
que dicen algo como,

00:32:16.030 --> 00:32:18.960
"Hey, este contenido sigue
fallando, ¿por qué no está ahí?"

00:32:18.960 --> 00:32:20.610
Esto puede ayudar a solucionarlo.

00:32:20.610 --> 00:32:23.490
Sí, no estamos verificando cuál
es la salida del lector de pantalla.

00:32:23.490 --> 00:32:25.590
Sólo estamos verificando para
asegurarnos de que el contenido

00:32:25.590 --> 00:32:27.790
sea accesible desde un punto de vista funcional.

00:32:27.790 --> 00:32:31.060
Y ésto puede contribuir en gran medida a que
sea más fácil para todos

00:32:31.060 --> 00:32:33.000
ver eso
y para los equipos de desarrollo, depurar.

00:32:33.000 --> 00:32:38.310
Es una excelente manera de participar y
lograr que más personas participen.

00:32:38.310 --> 00:32:40.850
Así que, mejores prácticas para esto;

00:32:40.850 --> 00:32:45.630
Estoy seguro de que las pruebas de regresión están
etiquetadas correctamente en sus pruebas de UI.

00:32:45.630 --> 00:32:48.890
Entonces, usen A11y o Accessibilidad
en las pruebas para saber

00:32:48.890 --> 00:32:51.220
que es una
prueba de regresión de accesibilidad.

00:32:51.220 --> 00:32:53.780 
Asegúrense de que se solicite
la funcionalidad de accesibilidad para las pruebas de interfaz de usuario.

00:32:53.780 --> 00:32:57.960
Así, por ejemplo,
criterios de aceptación. La mayoría de las empresas

00:32:57.960 --> 00:33:00.070
y equipos no tienen
criterios de aceptación para la accesibilidad.

00:33:00.070 --> 00:33:02.850
Si los tienen, entonces pueden de hecho
escribir pruebas de regresión.

00:33:02.850 --> 00:33:05.030
para ese
criterio de aceptación, lo cual es genial.

00:33:06.090 --> 00:33:07.670
Asegúrense de que
los equipos de desarrollo sepan que ésto

00:33:07.670 --> 00:33:10.350
no reemplaza las pruebas de lectores de pantalla 
con el público habitual.

00:33:10.350 --> 00:33:11.150
Eso es algo difícil de vender.

00:33:11.150 --> 00:33:13.220
Se los diré ahora mismo,
porque toman este camino,

00:33:13.220 --> 00:33:16.280
mucha gente dirá, "Hey, quiero
automatizar toda la accesibilidad".

00:33:16.280 --> 00:33:20.140
No se puede, pero esto ayudará a
aliviar el dolor de asegurarse

00:33:20.140 --> 00:33:23.420
que el contenido que ya es accesible
siga siendo accesible

00:33:23.420 --> 00:33:26.690
a menos que surja algo en el
camino, como errores del lector de pantalla

00:33:26.690 --> 00:33:27.210
o cosas así.

00:33:27.210 --> 00:33:28.800
Esos son muy pocos y espaciados.

00:33:28.800 --> 00:33:32.350
Por lo tanto, simplemente garantiza que el contenido sea
accesible desde el principio.

00:33:34.030 --> 00:33:36.330
Así que la fase uno, Linting.

00:33:36.330 --> 00:33:38.960
Fase dos,
bibliotecas de pruebas de accesibilidad.

00:33:38.960 --> 00:33:40.000
Fase tres, prueba de regresión.

00:33:40.000 --> 00:33:43.850
Ahora me van a preguntar, Mark,
en esta primera diapositiva que tenías aquí,

00:33:43.850 --> 00:33:47.230
tenías esta cosa encantadora que decía
fase cero. Vas a decir,

00:33:47.230 --> 00:33:50.720
¿Y qué pasa con las extensiones?
Tienen razón.

00:33:50.720 --> 00:33:54.210
Las extensiones existen y tienen
un impacto útil para la automatización.

00:33:55.230 --> 00:33:56.760
Aquí está mi experiencia
con las extensiones.

00:33:56.760 --> 00:33:59.490
No hay una manera real en el ciclo 
de vida de desarrollo de rastrear

00:33:59.490 --> 00:34:01.750
si alguien de hecho
está usando una extensión.

00:34:01.750 --> 00:34:05.440
Hola, fui desarrollador
durante mucho tiempo.

00:34:05.440 --> 00:34:08.870
Si me das algo por lo que voy
a estar en un código de honor,

00:34:08.870 --> 00:34:12.100
en un entorno ágil que no
sabe nada sobre accesibilidad,

00:34:12.100 --> 00:34:12.640
¿adivinen qué?

00:34:12.640 --> 00:34:14.030
No voy a hacerlo.

00:34:14.030 --> 00:34:16.010
Porque código de honor
no es algo

00:34:16.010 --> 00:34:18.960
por lo que esté marcando estrictamente una casilla
de verificación, es un criterio de aceptación,

00:34:18.960 --> 00:34:19.960
cosas así.

00:34:20.850 --> 00:34:21.610
¿Adivinen qué?

00:34:21.610 --> 00:34:25.040
La mayoría de los equipos que sólo usan extensiones
terminan enviando cosas a producción

00:34:25.040 --> 00:34:27.250
porque no hay forma de comprobarlas.

00:34:27.250 --> 00:34:28.930
Realmente no la hay.

00:34:28.930 --> 00:34:31.810
Por lo tanto, las extensiones siempre se pueden
cuando se construye

00:34:31.810 --> 00:34:32.830
y crea contenido nuevo.

00:34:34.000 --> 00:34:40.170
Pero las fases y la automatización de la accesibilidad, 
uno, dos, tres,

00:34:40.170 --> 00:34:42.360
ayudan a reforzar el
uso de esas extensiones.

00:34:42.360 --> 00:34:46.320
Entonces, si estoy creando mi contenido,
lo desarrollo y puedo ejecutar mi extensión

00:34:46.320 --> 00:34:48.690
en mi localhost y digo:
"Hey, hay un problema".

00:34:48.690 --> 00:34:52.290
Y puedo experimentar e intentar
arreglarlo en vivo y luego agregarlo

00:34:52.290 --> 00:34:53.400
a mi código.

00:34:53.400 --> 00:34:57.160
Ese es el uso práctico que veo
una y otra vez en los equipos.

00:34:57.160 --> 00:35:02.170
Tendemos a ver que las extensiones se
utilicen como una especie de patio de juegos.

00:35:02.170 --> 00:35:05.750
para poder ver los
problemas de accesibilidad y luego solucionarlos en vivo.

00:35:05.750 --> 00:35:07.400
Esto ayuda a hacer cumplir eso.

00:35:07.400 --> 00:35:11.590
Pero lo más importante es que con
las extensiones es muy difícil hacer un seguimiento.

00:35:11.590 --> 00:35:14.360
He visto a muchos escuadrones
decir: "Hey, haz una captura de pantalla

00:35:14.360 --> 00:35:17.060
de los problemas de accesibilidad"
y no hay problemas.

00:35:17.060 --> 00:35:19.510
Sí, ya he visto
al sistema engañado

00:35:19.510 --> 00:35:21.280
donde alguien hace
la misma captura de pantalla

00:35:21.280 --> 00:35:22.830
y dice, mira, está arreglado.

00:35:22.830 --> 00:35:25.940
Entonces las extensiones tienen un
lugar dentro de la automatización.

00:35:25.940 --> 00:35:26.230
Lo hacen,

00:35:26.230 --> 00:35:29.290
en un 100% porque muchos
escuadrones las usan.

00:35:29.290 --> 00:35:31.940
Pero en cuanto a su implementación y
su aplicación en el día a día,

00:35:31.940 --> 00:35:35.320
se tienen que usar las
partes de la fase uno, la fase dos,

00:35:35.320 --> 00:35:38.980
y si se llega a la fase tres, la fase
tres, para tener extensiones 

00:35:38.980 --> 00:35:41.510
que sean utilizadas adecuadamente como
deben ser.

00:35:41.510 --> 00:35:45.020
Ir más allá de lo que
hacen las pruebas de automatización.

00:35:45.020 --> 00:35:47.332
Es muy difícil implementar
las extensiones

00:35:47.333 --> 00:35:48.950
como para decir, "Hey, voy

00:35:48.950 --> 00:35:50.300
a utilizar extensiones y se acabó".

00:35:52.651 --> 00:35:56.351
Para darle un poco más de forma 
a esto.

00:35:58.040 --> 00:36:02.570
Yo digo este término, Merrill Evans
también dice un término similar a ésto,

00:36:02.570 --> 00:36:03.850
"pequeñas victorias para grandes ganancias".

00:36:03.850 --> 00:36:08.220
Muchas de las reacciones que recibo de
ésto es que estas

00:36:08.220 --> 00:36:09.790
fases para automatización son demasiado.

00:36:09.790 --> 00:36:11.510
Tienen razón, lo son.

00:36:11.510 --> 00:36:14.300
Pero se los digo desde ahora
mismo, la forma de entrar

00:36:14.300 --> 00:36:18.820
en el ciclo de vida del desarrollo es 
ajustándose a lo que ya está hecho

00:36:18.820 --> 00:36:22.270
La accesibilidad durante mucho
tiempo se ha visto como algo

00:36:22.270 --> 00:36:24.840
eso ralentiza todo el proceso.

00:36:24.840 --> 00:36:26.200
Lo ralentiza todo.

00:36:26.200 --> 00:36:29.100
Entonces entró la automatización para decir,
sí, aceleremos esa copia de seguridad.

00:36:29.100 --> 00:36:32.970
Pero el problema es que
la automatización casi fué demasiado lejos.

00:36:32.970 --> 00:36:36.310
Entonces, lo que terminó sucediendo es
que debido a que la automatización fué demasiado lejos,

00:36:36.310 --> 00:36:40.680
sobrepoblamos,
sobrecargamos el entorno de desarrollo,

00:36:40.680 --> 00:36:42.700
todas estas cosas diferentes
que podemos usar para la automatización.

00:36:42.700 --> 00:36:47.420
Y ahora nuestros desarrolladores volvieron y dijeron,
"ah, esto es demasiado otra vez".

00:36:47.420 --> 00:36:49.690
Así que es como un ciclo.

00:36:49.690 --> 00:36:55.260
Así que implementarlo gradualmente en fases nos permite
establecer una cultura

00:36:55.260 --> 00:36:58.120
de accesibilidad para el futuro.

00:36:58.120 --> 00:37:00.780
Mucha gente piensa que cuando
digo esto, no es verdad.

00:37:00.780 --> 00:37:02.000
Realmente lo es.

00:37:02.000 --> 00:37:05.790
Tan pequeña como sea la automatización en una pequeña
subtarea de las cosas que hace

00:37:05.790 --> 00:37:08.310
en una pequeña cantidad de
problemas que detecta.

00:37:08.310 --> 00:37:14.790
Realmente tiene consistentemente
el trasfondo de la accesibilidad.

00:37:14.790 --> 00:37:16.947
Una ola puede llegar desde
arriba muy rápido

00:37:16.948 --> 00:37:18.780
y decir, "hey, arregla todo esto".

00:37:18.780 --> 00:37:21.060
Las olas se pueden hacer grandes,
las olas se pueden hacer pequeñas,

00:37:21.060 --> 00:37:22.600
pero las corrientes subterráneas
siempre seguirán ahí.

00:37:22.600 --> 00:37:24.940
Ustedes quieren que la accesibilidad
permanezca como una corriente subyacente.

00:37:26.150 --> 00:37:28.320
Que esté constantemente ahí y
recuerde constantemente a todos

00:37:28.320 --> 00:37:30.630
que la accesibilidad importa
y el impacto que tiene.

00:37:30.630 --> 00:37:34.030
Entonces, si continuamos diciendo que hagamos
automatización, terminaremos

00:37:34.030 --> 00:37:35.450
en el mismo ciclo en el que hemos estado.

00:37:35.450 --> 00:37:37.690
Así que tenemos que empezar a
implementarlo gradualmente para que se mantenga.

00:37:37.690 --> 00:37:41.930
Y una última palabra
antes de terminar aquí.

00:37:41.930 --> 00:37:45.660
La accesibilidad automatizada, a
decir verdad, tiene una mala reputación

00:37:45.660 --> 00:37:47.540
en nuestro campo, y con razón.

00:37:48.560 --> 00:37:50.000
Existen overlays.

00:37:51.280 --> 00:37:53.950
Todavía hay programadores
que piensan que éstos resuelven

00:37:53.950 --> 00:37:55.030
todos los problemas de accesibilidad.

00:37:55.030 --> 00:37:56.820
"Puedo automatizar cada cosa".

00:37:58.070 --> 00:38:00.870
Todavía hay personas que ahora
podrían actualizar esto y decir que creen

00:38:00.870 --> 00:38:02.800
que la IA arreglará
todo con esto.

00:38:02.800 --> 00:38:04.910
Porque está automatizado.

00:38:04.910 --> 00:38:05.910
Ésta es la cuestón.

00:38:05.910 --> 00:38:08.350
Al final del día,
es un portal y una entrada.

00:38:08.350 --> 00:38:10.960
hacia un área que es
realmente difícil de penetrar.

00:38:10.960 --> 00:38:13.890
Lo digo una y otra vez.

00:38:13.890 --> 00:38:19.420
Las corazas de los equipos de desarrollo
son extremadamente difíciles de romper.

00:38:19.420 --> 00:38:21.820
Día con día, en el
campo de la accesibilidad decimos:

00:38:21.820 --> 00:38:23.920
¿Por qué no hicieron eso
accesible?

00:38:23.920 --> 00:38:26.290
A decir verdad, yo
también me frustro, no se preocupen.

00:38:26.290 --> 00:38:30.300
Pero con todo lo que
los equipos ágiles tienen que hacer, los plazos ajustados

00:38:30.300 --> 00:38:33.480
y el aplazamiento de tareas,
se vuelve realmente complicado para ellos.

00:38:33.480 --> 00:38:38.730
Entonces romper esa coraza es muy
difícil porque no quieren

00:38:38.730 --> 00:38:41.320
agregarse más tareas o cualquier otra
cosa de más y lo entiendo.

00:38:41.320 --> 00:38:42.500
Estuve allí, he hecho eso.

00:38:42.500 --> 00:38:46.320
Así que hay que ir introduciéndolo poco a poco
para llegar a donde necesita ir.

00:38:46.320 --> 00:38:48.960
Esto realmente puede ayudar a un
equipo de desarrollo a aprender rápidamente

00:38:48.960 --> 00:38:50.410
sin tener que disminuir la velocidad.

00:38:50.410 --> 00:38:55.010
Y puede construir una cultura en
el equipo de desarrollo a medida que se avanza.

00:38:55.010 --> 00:38:59.210
Volviendo a la
encuesta de webAIM, nos dice una cosa:

00:38:59.210 --> 00:39:00.912
lo que hemos estado haciendo desde
el punto de vista de la automatización

00:39:00.913 --> 00:39:01.600
todavía no funciona.

00:39:01.600 --> 00:39:04.890
Simplemente la estamos aventando contra la pared
y diciendo, "hey, ve y haz automatización"

00:39:04.890 --> 00:39:06.890
Eso no funciona.

00:39:06.890 --> 00:39:08.398
Introducirla gradualmente, tener un plan,

00:39:08.399 --> 00:39:10.530
entender
consistentemente lo que tenemos que

00:39:10.530 --> 00:39:15.720
hacer para garantizar que perdure,
ayudará a todos los equipos de desarrollo

00:39:15.720 --> 00:39:18.040
adoptar la accesibilidad
y ponerla en práctica

00:39:18.040 --> 00:39:23.030
Así que, lo último que quiero decir es que construyamos
una mejor automatización para la accesibilidad.

00:39:23.030 --> 00:39:25.490
Acabemos con la reputación
de que la automatización va a

00:39:25.491 --> 00:39:26.600
invadirlo todo.

00:39:26.600 --> 00:39:28.220
Todos creen que
va a gobernar el mundo.

00:39:28.220 --> 00:39:29.260
No.

00:39:29.260 --> 00:39:32.790
Es una puerta de entrada para
los equipos de desarrollo que les permite realmente,

00:39:32.790 --> 00:39:35.320
aprender verdaderamente sobre
la accesibilidad a gran velocidad

00:39:35.320 --> 00:39:39.170
y construir esa cultura en torno a
la accesibilidad en el futuro.

00:39:39.170 --> 00:39:41.480
Así que simplemente construyamos
una mejor automatización a11y para todos.

00:39:41.480 --> 00:39:45.520
y hagamos a la accesibilidad
parte del ciclo de vida del desarrollador.

00:39:46.700 --> 00:39:47.210
Y eso es todo.

00:39:47.210 --> 00:39:49.020
Y eso es todo por mi parte.

00:39:49.020 --> 00:39:50.020
Woohoo.

00:39:51.060 --> 00:39:52.060
Probablemente haga más café ahora.

00:39:53.010 --> 00:39:55.080
JOOST: Bueno,
te has ganado tu café.

00:39:55.080 --> 00:39:55.760
Eso es seguro.

00:39:55.760 --> 00:39:56.490
Gracias, Mark.

00:39:56.490 --> 00:39:57.830
Eso fue excelente.

00:39:57.830 --> 00:39:59.460
Muchas gracias.

00:39:59.460 --> 00:40:01.040
Estaba tomando notas.

00:40:01.040 --> 00:40:03.010
Una de las primeras
cosas de las que me he dado cuenta

00:40:03.010 --> 00:40:05.963
mientras estaba viendo
tu presentación

00:40:05.964 --> 00:40:07.620
Es que siempre hemos tenido muchas

00:40:07.620 --> 00:40:10.140
pruebas automatizadas en
Yoast, por lo que veo.

00:40:11.160 --> 00:40:14.520
Y no creo que hayamos
llegado realmente al punto

00:40:14.520 --> 00:40:17.270
donde hiciéramos muchas
pruebas de accesibilidad automatizadas.

00:40:18.340 --> 00:40:22.120
Pero muchas de ellas parecieran
en realidad muy fáciles

00:40:22.120 --> 00:40:24.080
de copiar y pegar de un
proyecto a otro.

00:40:24.980 --> 00:40:25.330
MARK: Sí.

00:40:25.330 --> 00:40:27.200
JOOST: ¿Hay algún
lugar donde la gente comparta

00:40:27.200 --> 00:40:32.180
estas cosas de código abierto en línea 
de manera que podamos hacer eso?

00:40:32.180 --> 00:40:33.120
¿Dónde estás haciendo eso?

00:40:34.610 --> 00:40:37.820
MARK: Yo puedo compartir esto con
todos los que están en los canales de Slack

00:40:37.820 --> 00:40:39.290
y lo compartiré en
Twitter y LinkedIn.

00:40:39.290 --> 00:40:45.320
De hecho estoy preparando un
paquete completo.

00:40:45.320 --> 00:40:47.830
Es una de las cosas que
estoy en proceso de hacer.

00:40:47.830 --> 00:40:52.930
Estoy, de hecho, creando un
conjunto completo de ejemplos accesibles.

00:40:52.930 --> 00:40:53.880
que se encuentran por ahí.

00:40:53.880 --> 00:40:55.220
Puedo compartir eso con
todos después de esto.

00:40:55.220 --> 00:40:56.620
Hay sólo un par de ellos
ahí en este momento.

00:40:56.620 --> 00:40:57.900
Este es mi React
en mi teléfono Cypher.

00:40:57.900 --> 00:41:01.340
Lo hago cuando tengo tiempo, pero ¿qué
pasa cuando tienes dos hijos?

00:41:01.340 --> 00:41:04.760
Pero tengo ejemplos por ahí
que funcionan como demostración.

00:41:05.880 --> 00:41:08.160 
Hay también algunos ejemplos
que se encuentran por ahí afuera.

00:41:08.160 --> 00:41:13.580
Creo que en cuanto a código abierto, Deque
Systems tiene algo para axe-core.

00:41:13.580 --> 00:41:14.960
Sólo hay unos pocos.

00:41:14.960 --> 00:41:18.230
Pero mi objetivo es crear
bibliotecas de ejemplo para demostrar

00:41:18.230 --> 00:41:20.290
lo fácil que es copiar
y pegar esas cosas.

00:41:20.290 --> 00:41:23.350
Porque verdaderamente, justo de lo que estás
hablando, ese es el caso.

00:41:23.350 --> 00:41:27.360
Literalmente, puedes copiar y pegar
una vez que tengas esos casos de prueba.

00:41:27.360 --> 00:41:27.930
en todos los ámbitos.

00:41:27.930 --> 00:41:29.940
Y todos tienden a
saltar sobre mí para decir,

00:41:29.940 --> 00:41:31.450
copiar y pegar ¿cómo, Mark,
de qué estás hablando?

00:41:31.450 --> 00:41:32.280
No se puede sólo copiar y pegar.

00:41:32.280 --> 00:41:33.370
Y yo digo, sí se puede.

00:41:33.370 --> 00:41:36.230
Se establecen los casos de prueba
correctamente y todo configurado

00:41:36.230 --> 00:41:38.480
de manera que
sea accesible en voz alta.

00:41:38.480 --> 00:41:39.440
Es relativamente sencillo.

00:41:39.440 --> 00:41:43.510 
Entonces sí, también puedo publicar algunos de esos 
recursos que conozco después de esto.

00:41:44.380 --> 00:41:47.290
JOOST: Bueno, sí
eso sería fantástico porque sé

00:41:47.290 --> 00:41:50.880
que tampoco hay mucho de
esto todavía en el núcleo de WordPress.

00:41:50.880 --> 00:41:53.243
Y creo que
sería de gran beneficio

00:41:53.244 --> 00:41:57.000
hacer un poco más
de eso porque estoy de acuerdo contigo.

00:41:57.000 --> 00:42:03.260
Lo que más he escuchado en contra
de trabajos de accesibilidad como éste es,

00:42:03.260 --> 00:42:04.710
que sí, todo se hace más lento.

00:42:04.710 --> 00:42:08.140
Y es como si estuviera harto y
cansado de escuchar ese argumento.

00:42:09.680 --> 00:42:12.520
MARK: Dondequiera que voy, 
es el mismo argumento una

00:42:12.520 --> 00:42:13.070
y otra vez.

00:42:13.070 --> 00:42:14.546
Y nuevamente,
ese es el rechazo inicial

00:42:14.547 --> 00:42:18.250
contra el que tenemos que luchar,
que sólo nos va a ralentizar.

00:42:18.250 --> 00:42:21.080
Y la verdad es
que mi experiencia

00:42:21.080 --> 00:42:25.750
con la introducción gradual de fases ha funcionado
relativamente bien para que los equipos

00:42:25.750 --> 00:42:28.260
digan, "hey,
estos son complementos realmente simples

00:42:28.260 --> 00:42:29.790
para lo que estamos haciendo ahora mismo.

00:42:29.790 --> 00:42:31.390
Y sea lo que sea que estén usando,
lo vamos a construir

00:42:31.390 --> 00:42:32.280
con lo que ustedes tienen".

00:42:33.300 --> 00:42:34.210
JOOST: Perfecto.

00:42:34.210 --> 00:42:36.780
Bien, tenemos las primeras
preguntas.

00:42:36.780 --> 00:42:40.040
Ben Ogilfee pregunta:
¿Tienes conocimiento de algunas consideraciones

00:42:40.040 --> 00:42:45.010
o limitaciones de algunos de
estos enfoques tal como se aplican

00:42:45.010 --> 00:42:46.420
¿a las compilaciones de WordPress?

00:42:46.420 --> 00:42:47.600
MARK: Sí.

00:42:47.600 --> 00:42:51.460
Algunas de las cosas
de las que hablamos en cuanto a los linters,

00:42:51.460 --> 00:42:55.110
las compilaciones de accesibilidad por sí mismas,
al igual que sus integraciones

00:42:55.110 --> 00:42:57.840
no existen aún
dentro de las compilaciones de WordPress.

00:42:57.840 --> 00:43:01.630
Algunos de ellos sí, algunos de los
linters que revisé existen

00:43:01.630 --> 00:43:02.960
para ello, pero algunos no.

00:43:02.960 --> 00:43:05.100
Eso es sólo un producto de cómo
algunas de las bibliotecas de prueba

00:43:05.100 --> 00:43:06.360
y las cosas funcionan.

00:43:06.360 --> 00:43:10.300
Entonces esas serían las únicas
limitaciones que existen en este momento.

00:43:10.300 --> 00:43:14.690
Así que ¿las compilaciones de accesibilidad que están disponibles
son las únicas que existen?

00:43:14.690 --> 00:43:17.610
A decir verdad, es que es difícil
porque a veces 

00:43:17.610 --> 00:43:22.630
cuando ejecutas cosas con
eso, te encuentras con problemas

00:43:22.630 --> 00:43:25.910
donde no los tenías.

00:43:25.910 --> 00:43:28.900
Por ejemplo,
estaba viendo uno.

00:43:28.900 --> 00:43:31.200
Creo que era uno de Vue.

00:43:31.200 --> 00:43:33.630
El sitio de WordPress
fue creado en Vue.

00:43:33.630 --> 00:43:35.880
No tenía
reglas de accesibilidad ni de linting,

00:43:35.880 --> 00:43:38.830
pero había un linter general que
incluía reglas de accesibilidad.

00:43:38.830 --> 00:43:41.190
En el peor de los casos,
tira del general.

00:43:41.190 --> 00:43:44.660
Al menos así se
realizan comprobaciones de accesibilidad a medida que se crea el contenido.

00:43:44.660 --> 00:43:47.260
Pero realmente la limitación es
si están disponibles o no.

00:43:47.260 --> 00:43:48.810
¿desde el punto de vista de linting o
de biblioteca

00:43:49.500 --> 00:43:50.540
JOOST: Sí, genial.

00:43:53.170 --> 00:43:56.640
Ben Eisenberg pregunta:
¿qué pasa con la actualización de sitios antiguos?

00:43:56.640 --> 00:43:59.241
¿En qué ventajas fáciles puede uno
centrarse para sitios antiguos

00:43:59.242 --> 00:44:00.790
que necesitan mantenimiento?

00:44:00.790 --> 00:44:01.730
MARK: Oh, está bien.

00:44:01.730 --> 00:44:04.450
Hay dos cosas
con los sitios antiguos.

00:44:04.450 --> 00:44:09.810
Una cosa que siempre sugiero,
con un sitio antiguo,

00:44:09.810 --> 00:44:12.473
es que hay dos cosas
que se pueden hacer dependiendo

00:44:12.474 --> 00:44:14.670
de cuánto realmente se actualice,

00:44:15.720 --> 00:44:18.590
si se desea revisar
y actualizar el código antiguo, está bien.

00:44:18.590 --> 00:44:21.750
Pero hay algunos equipos que
conozco que en realidad han

00:44:21.750 --> 00:44:24.130
pasado por eso – y sé que
todos se van a estremecer

00:44:24.130 --> 00:44:27.280
cuando diga esto, – y encontraron
algunos de los problemas simples

00:44:27.280 --> 00:44:30.020
porque en realidad no tienen
acceso al código.

00:44:30.020 --> 00:44:32.183
Simplemente revisaron
y agregaron código JavaScript.

00:44:32.184 --> 00:44:33.560
para solucionar problemas específicos.

00:44:33.560 --> 00:44:35.310
Ellos no van y dicen algo
como "hey, dame algo general para corregir".

00:44:35.310 --> 00:44:38.120
Sino que están solucionando
problemas específicos con JavaScript.

00:44:38.120 --> 00:44:39.220
Esa es una forma.

00:44:39.220 --> 00:44:44.170
La otra cosa que sugiero para
sitios antiguos es que si se tiene una manera

00:44:44.170 --> 00:44:46.830
de establecer una
prueba de integración para uno mismo, como,

00:44:46.830 --> 00:44:48.690
"Hey, configura una biblioteca para
revisar esas cosas"

00:44:48.690 --> 00:44:52.550
y verificar los problemas, como
mínimo, solucionen los problemas automatizados.

00:44:52.550 --> 00:44:56.880
La mayoría de los sitios antiguos
en realidad están hechos con HTML semántico.

00:44:56.880 --> 00:44:59.840
Entonces, la mayoría de los problemas
que se encuentran surgen

00:44:59.840 --> 00:45:06.750
porque faltan
atributos de aria o cosas por el estilo.

00:45:06.750 --> 00:45:09.950
Semánticamente es genial, salvo que
se están perdiendo cosas pequeñas.

00:45:09.950 --> 00:45:13.270
Si se puede ejecutar un conjunto de pruebas
contra eso o incluso tener una extensión,

00:45:13.270 --> 00:45:15.920
eso hace que sea más fácil de ejecutar; pero
esas son dos cosas que normalmente

00:45:15.920 --> 00:45:18.160
veo con los sitios antiguos.

00:45:18.160 --> 00:45:21.220
Sólo intentar arreglar lo que se pueda, 
ya sea con JavaScript

00:45:21.220 --> 00:45:23.810
o lo que sea y simplemente quitar del camino
los problemas simples.

00:45:25.420 --> 00:45:26.940
JOOST: Genial.

00:45:26.940 --> 00:45:30.670
Tenemos otra pregunta o en realidad
creo que son tres preguntas

00:45:30.670 --> 00:45:32.250
así que las voy a preguntar
una por una.

00:45:32.250 --> 00:45:36.240
De Scott Thorneburn: ¿Cuánto
tiempo, en promedio, se tarda uno

00:45:36.240 --> 00:45:39.140
en ejecutar un cambio cuando
se implementa con un equipo de desarrollo?.

00:45:40.430 --> 00:45:41.110
MARK: ¡Juu!

00:45:41.110 --> 00:45:46.720
Bien, la fase uno y la fase
dos si se tiene, específicamente para el linting

00:45:46.720 --> 00:45:49.550
si se sabe que se está
usando un linter específico,

00:45:49.550 --> 00:45:51.500
y simplemente se puede decir "activar
reglas de accesibilidad",

00:45:51.500 --> 00:45:53.720
esa fase uno puede tomar una semana.

00:45:53.720 --> 00:45:55.460
Y simplemente decir: sí, esto
ahora es parte del proceso.

00:45:55.460 --> 00:45:58.540
Estamos usando
reglas de accesibilidad y tienen que ajustarse.

00:45:58.540 --> 00:46:04.790
Lo más rápido que he visto que la fase
uno y la fase dos duran, es un mes.

00:46:04.790 --> 00:46:08.790
Entonces, si están haciendo
dos sprints a la semana, dos, como dos sprints.

00:46:10.210 --> 00:46:12.370
Pero normalmente se trata
de lo siguiente.

00:46:12.370 --> 00:46:14.430
La fase uno normalmente consiste
en uno o dos sprints.

00:46:15.440 --> 00:46:20.900
Fase tres, normalmente porque es
la gente de control de calidad y a la gente de control de calidad realmente le importan

00:46:20.900 --> 00:46:22.990
las pruebas de interfaz de usuario ¿cierto?

00:46:22.990 --> 00:46:25.990
Normalmente lleva alrededor de
un par de meses, tres meses.

00:46:25.990 --> 00:46:27.260
Y luego
las pruebas de regresión, seré honesto.

00:46:27.260 --> 00:46:31.230
La prueba de regresión es
muy difícil de obtener.

00:46:31.230 --> 00:46:33.270
Hablo de esto
porque es realmente increíble

00:46:33.270 --> 00:46:36.620
y porque creo que
tiene mucho valor.

00:46:36.620 --> 00:46:39.980
Sólo he visto dos
equipos de desarrollo u organizaciones en las que he trabajado

00:46:39.980 --> 00:46:42.170
que realmente lo han logrado.

00:46:42.170 --> 00:46:45.250
Lleva mucho tiempo llegar ahí
porque una vez que alcanzas la fase uno,

00:46:45.250 --> 00:46:47.720
en la segunda fase, muchas
veces es como, ¡oh Dios mío!,

00:46:47.720 --> 00:46:49.170
¿De dónde surgieron todos estos
problemas?

00:46:49.170 --> 00:46:51.360
Y luego se tiene que empezar
a idear un proceso para solucionarlos

00:46:51.360 --> 00:46:52.750
e integrarlos.

00:46:52.750 --> 00:46:55.050 
Aunque ese es normalmente el
período de tiempo con un equipo de desarrollo.

00:46:56.270 --> 00:46:57.170
JOOST: Genial.

00:46:57.170 --> 00:47:02.930
¿Y cuál estimarías que
sería el costo y la desaceleración inicial

00:47:02.930 --> 00:47:04.620
en los proyectos para poner
esto en marcha?

00:47:04.620 --> 00:47:05.610
MARK: Claro.

00:47:05.610 --> 00:47:07.450
Entonces para el Linting, nada.

00:47:07.450 --> 00:47:09.110
No hay ningún argumento
en contra del Linting.

00:47:09.110 --> 00:47:10.660
Si se tiene un linter
ejecutándose ahora mismo,

00:47:10.660 --> 00:47:13.910
ejecuten las reglas de accesibilidad, que están
activadas, y no se ralentiza nada.

00:47:13.910 --> 00:47:16.920
Es posible que un desarrollador haya tardado 30
segundos más en terminar,

00:47:16.920 --> 00:47:19.610
"Oh, necesito un atributo alt en
esto, lo entiendo".

00:47:21.270 --> 00:47:24.850
Para algo como las
bibliotecas de prueba y cosas así,

00:47:24.850 --> 00:47:27.510
podrían estar pensando si 
yo las añadiría a un sprint,

00:47:27.510 --> 00:47:29.860
esto podría ralentizar un
poco a la gente de control de calidad.

00:47:29.860 --> 00:47:32.740
Sin embargo,
si tienen un equipo de control de calidad o alguien

00:47:32.740 --> 00:47:35.360
quién esté escribiendo por si mismo
el caso de prueba, como mostramos,

00:47:35.360 --> 00:47:37.430
La configuración inicial es
realmente la parte difícil.

00:47:37.430 --> 00:47:40.470
Después de eso, es sólo
copiar, pegar y repetir.

00:47:40.470 --> 00:47:44.200
Entonces, la desaceleración es probablemente un sprint
o dos para configurarlo y ponerlo en marcha,

00:47:44.200 --> 00:47:46.620
pero realmente no hay
mucho costo por la desaceleración.

00:47:46.620 --> 00:47:47.810
Pruebas de regresión, claro.

00:47:47.810 --> 00:47:50.010
Eso toma un poco de tiempo
entenderlo, Hey, ¿cómo voy

00:47:50.010 --> 00:47:52.060
escribir
pruebas de regresión funcional para algo?

00:47:52.060 --> 00:47:54.361
Pero los dos primeros,
el primero específicamente,

00:47:54.362 --> 00:47:56.020
No tiene problemas con la desaceleración.

00:47:56.020 --> 00:47:58.530
Con el segundo, puede que haya
algo de desaceleración, pero todo

00:47:58.530 --> 00:48:00.770
depende también de la
estructura del proyecto.

00:48:00.770 --> 00:48:01.900
JOOST: Claro.

00:48:01.900 --> 00:48:06.240
¿Y cómo llegas a un acuerdo con
los desarrolladores sobre qué herramientas automatizadas utilizar?

00:48:06.240 --> 00:48:10.610
¿Usas siempre 
lo que ellos ya están usando?

00:48:10.610 --> 00:48:13.150
MARK: Sí. Siempre recurro a
lo que ellos están haciendo.

00:48:13.150 --> 00:48:16.700
La primera pregunta que hago es: Hey,
¿qué usan para un equipo?

00:48:16.700 --> 00:48:18.793
¿Qué utilizan para
las pruebas automatizadas?

00:48:18.794 --> 00:48:23.520
Y luego allí llenamos los vacíos
con accesibilidad.

00:48:23.520 --> 00:48:26.570
Porque si no lo han
decidido, siempre digo esto,

00:48:26.570 --> 00:48:30.030
si no han decidido
una estrategia de prueba, presiónenlos

00:48:30.030 --> 00:48:32.690
a que lo descubran ellos mismos
porque si van y dicen, "bueno,

00:48:32.690 --> 00:48:36.170
deberíamos usar esto",
siempre termina en desastre.

00:48:36.170 --> 00:48:38.200
Porque entonces empiezan a
decir, "oh no, no, no,

00:48:38.200 --> 00:48:38.820
vamos a usar mejor esto".

00:48:38.820 --> 00:48:39.530
Es como, OK, genial.

00:48:39.530 --> 00:48:43.010
Entonces, si un equipo ya lo sabe,
vayan con lo que ya tiene, vayan

00:48:43.010 --> 00:48:45.650
con lo que estén usando y digan:
"Hey, vamos a empezar

00:48:45.650 --> 00:48:48.130
con accesibilidad en esto".
Y si ellos no lo hacen,

00:48:48.130 --> 00:48:51.190
entonces simplemente digan, está
bien, descúbranlo ustedes primero.

00:48:51.190 --> 00:48:52.270
Ésta es sólo mi experiencia.

00:48:52.270 --> 00:48:53.940
Resuélvanlo ustedes primero,
y yo regresaré y estudiaré

00:48:53.940 --> 00:48:56.020
lo que deberíamos estar haciendo desde el
punto de vista de la accesibilidad.

00:48:56.020 --> 00:48:59.140
Si lo forzamos desde la accesibilidad,
entonces se vuelve un caos.

00:48:59.140 --> 00:49:02.250
JOOST: Sí, lo aprecio muchísimo.

00:49:02.250 --> 00:49:06.840
Andrea Fershia pregunta, en 2017,
los servidores digitales del gobierno del Reino Unido

00:49:06.840 --> 00:49:11.280
realizaron una auditoría de los
verificadores automatizados de accesibilidad más populares

00:49:11.280 --> 00:49:14.750
y descubreron que incluso el mejor
era capaz de encontrar sólo el 40%

00:49:14.750 --> 00:49:15.570
de los problemas.

00:49:15.570 --> 00:49:15.910
MARK: Sí.

00:49:16.996 --> 00:49:19.850
JOOST: ¿Sabes por casualidad si
se han realizado nuevas auditorías desde entonces?,

00:49:19.850 --> 00:49:23.260 
¿o si se ha mejorado en general
la precisión de estas herramientas?

00:49:23.978 --> 00:49:26.410
MARK: Claro, resumiré
esto rápidamente.

00:49:26.410 --> 00:49:31.640
Andrea, ese es el término general:
entre el 30 y el 40 % de los problemas de accesibilidad.

00:49:31.640 --> 00:49:34.970
Lo único que puedo
decir diferente es que,

00:49:34.970 --> 00:49:36.950
Deque Systems hizo un estudio para esto.

00:49:36.950 --> 00:49:40.080
Alguien más también hizo un estudio 
sobre esto, pero no recuerdo quién fue.

00:49:40.080 --> 00:49:43.410
Deque Systems tomó todas las
auditorías de accesibilidad que había realizado

00:49:43.410 --> 00:49:45.140
desde un punto de vista manual y
automatizado.

00:49:45.140 --> 00:49:48.230
Juntaron todo y
dijeron, por volumen,

00:49:48.230 --> 00:49:50.450
¿Cuántos de los problemas
eran detectados por la automatización?

00:49:50.450 --> 00:49:54.130
Salieron con, que creo, 
el 56% de todos los problemas de accesibilidad,

00:49:54.130 --> 00:49:54.800
-eso es manual 

00:49:54.800 --> 00:49:57.040
y automatizado-, eran
detectados por la automatización.

00:49:57.040 --> 00:50:00.000
Eso es por volumen, no por
criterios de éxito ni nada de eso.

00:50:00.000 --> 00:50:02.960
De nuevo, es cómo dependiendo de cómo se vea

00:50:02.960 --> 00:50:06.410
Entonces, si se dice 30% de
criterios de éxito, 100%, es lo que quiero decir,

00:50:06.410 --> 00:50:07.760
100%, lo siento.

00:50:07.760 --> 00:50:09.650
Eso es lo que normalmente
también digo, ya que es el tercio inferior

00:50:09.650 --> 00:50:11.000
de los problemas de accesibilidad.

00:50:11.000 --> 00:50:13.130
Si se mira por volumen,
existen algunos estudios

00:50:13.130 --> 00:50:15.740
que dicen que está más cerca de 50
debido a todos los problemas

00:50:15.740 --> 00:50:18.220
que existen en la
web, pero no sé

00:50:18.220 --> 00:50:20.180
de nuevos estudios que
se hayan hecho, no.

00:50:21.970 --> 00:50:26.870
JOOST: Con esto llegamos al
final de nuestra lista de preguntas.

00:50:26.870 --> 00:50:29.090
y te vamos a aligerar.

00:50:29.090 --> 00:50:32.340
Gracias de nuevo Mark por
tu excelente presentación.

00:50:32.340 --> 00:50:34.550
y gracias a todos por asistir.

00:50:35.600 --> 00:50:38.140
Pueden continuar la
conversación en el chat

00:50:38.140 --> 00:50:45.390
o en las redes sociales usando los
hashtags wpa11yday y wpad2023.

00:50:45.390 --> 00:50:47.290
También
les agradeceríamos mucho que vayan

00:50:47.290 --> 00:50:51.400
al sitio web del día de la accesibilidad de WP, 
diagonal, feedback

00:50:51.400 --> 00:50:54.130
para proporcionar
comentarios anónimos rápidos para nuestros oradores,

00:50:54.130 --> 00:50:59.560
sobre nuestras presentaciones y mientras se
animan pueden participar para ganar una camiseta.

00:50:59.560 --> 00:51:02.550
Estén atentos para saber cómo
codificar para el acceso a palabras clave

00:51:02.550 --> 00:51:06.440
en WordPress, a continuación,
con Priti Rohra a las

00:51:06.440 --> 00:51:09.010
12:00 en punto UTC.

00:51:09.010 --> 00:51:12.460
Y mientras esperan no
olviden visitar nuestras páginas de patrocinadores

00:51:12.460 --> 00:51:17.020
para conseguir artículos virtuales y participar
para ganar fantásticos premios.

00:51:17.020 --> 00:51:20.120 
Este soy yo también
despidiéndome como MC por hoy.

00:51:20.120 --> 00:51:23.550
Espero que disfruten el resto del
día de accesibilidad de WordPress.

00:51:23.550 --> 00:51:25.380
y nos vemos
aquí después de una pausa.

00:51:28.620 --> 00:51:33.260
PONENTE 1: Gracias a
los patrocinadores del Día de la Accesibilidad de WordPress 2023.

00:51:33.260 --> 00:51:36.140
Patrocinador platino: Equalize Digital.

00:51:36.140 --> 00:51:38.890 
El plugin de verificación de accesibilidad
de Equalize Digital

00:51:38.890 --> 00:51:41.640
es una
herramienta de escaneo de accesibilidad automatizada

00:51:41.640 --> 00:51:44.820
que ayuda a que los sitios web de WordPress
sean y permanezcan accesibles.

00:51:46.070 --> 00:51:51.010
Patrocinador platino: Gravity Forms.
Gravity Forms es el generador 

00:51:51.010 --> 00:51:54.170
profesional de formularios que
se necesita para crear formularios hermosos,

00:51:54.170 --> 00:51:57.270
poderosos y accesibles.

00:51:57.270 --> 00:52:03.170
Patrocinadores de oro: 20i, Deque,
Empire Caption Solutions,

00:52:03.170 --> 00:52:05.360
Pressable y WP engine.

00:52:06.930 --> 00:52:13.800
Patrocinadores de plata: Code Geek, Drake
Cooper, GoDaddy, LoneRock Point,

00:52:13.800 --> 00:52:19.030
NerdPress, Website Overnight de
KineticIRIS, Rheola Networks,

00:52:20.290 --> 00:52:23.300
A11Y Collective y Blogsmith.

00:52:25.170 --> 00:52:30.580
Patrocinadores bronce: ExcessaCart,
GreenGeeks Web Hosting,

00:52:30.580 --> 00:52:38.580
Hall Analysis Consultoría SEO,
HDC, ITX, Ivy Cat, Metabox,

00:52:42.330 --> 00:52:47.243
Pixel Chefs, Simply Schedule
Appointments, SiteGround,

00:52:47.244 --> 00:52:52.470
Termageddon, Underrepresented
in Tech, Leaglot y Yoast.